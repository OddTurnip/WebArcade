<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku</title>
    <link rel="icon" type="image/x-icon" href="https://oddturnip.com/favicon_turnip.ico">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #eee;
            padding: 20px;
        }
        h1 { margin-bottom: 10px; color: #4ecdc4; }
        #gameCanvas {
            border: 4px solid #4a4a6a;
            border-radius: 4px;
            display: none;
            cursor: pointer;
        }
        #gameCanvas.visible { display: block; }
        #statusDisplay {
            margin-top: 15px;
            padding: 10px 20px;
            background: #2a2a4a;
            border-radius: 4px;
            display: none;
            gap: 40px;
            justify-content: center;
        }
        #statusDisplay.visible { display: flex; }
        .status-item { text-align: center; }
        .status-label { font-size: 12px; color: #888; margin-bottom: 5px; }
        .status-value { font-size: 24px; color: #4ecdc4; }
        .time .status-value { color: #ffe66d; }
        .difficulty .status-value { color: #ff6b6b; font-size: 16px; }
        #controls {
            margin-top: 15px;
            font-size: 11px;
            color: #888;
            text-align: center;
            max-width: 500px;
            line-height: 1.6;
        }
        #audioControls {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        #audioControls label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #audioControls input[type="checkbox"] {
            cursor: pointer;
            accent-color: #4ecdc4;
        }
        #configPanel {
            background: #2a2a4a;
            border-radius: 8px;
            padding: 15px 20px;
            margin-top: 15px;
        }
        .config-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .preset-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 12px;
        }
        .preset-btn {
            padding: 6px 12px;
            background: #3a3a5a;
            border: 2px solid #4a4a6a;
            border-radius: 4px;
            color: #aaa;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .preset-btn:hover {
            background: #4a4a6a;
            color: #fff;
            border-color: #4ecdc4;
        }
        .preset-btn.active {
            background: #4ecdc4;
            color: #1a1a2e;
            border-color: #4ecdc4;
        }
        .new-game-btn {
            padding: 8px 20px;
            background: #4ecdc4;
            border: none;
            border-radius: 4px;
            color: #1a1a2e;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        .new-game-btn:hover { background: #5fd9d1; }
        #titleScreen {
            text-align: center;
            padding: 60px 40px;
            background: #2a2a4a;
            border-radius: 8px;
            border: 4px solid #4a4a6a;
        }
        #titleScreen h2 { color: #4ecdc4; font-size: 28px; margin-bottom: 20px; }
        #titleScreen p { color: #888; font-size: 14px; margin-bottom: 30px; line-height: 1.6; }
        #titleScreen .start-btn {
            padding: 15px 40px;
            background: #4ecdc4;
            border: none;
            border-radius: 4px;
            color: #1a1a2e;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            margin: 5px;
        }
        #titleScreen .start-btn:hover { background: #5fd9d1; transform: scale(1.05); }
        .difficulty-info {
            margin-top: 20px;
            font-size: 11px;
            color: #666;
            line-height: 1.8;
        }
        .difficulty-info strong { color: #888; }
    </style>
</head>
<body>
    <h1>Sudoku</h1>

    <div id="titleScreen">
        <h2>Select Game Mode</h2>
        <p>Click a cell and type 1-9 to fill it<br>Complete the grid following Sudoku rules</p>
        <button class="start-btn" onclick="startGame(0)">Blank Grid</button>
        <br>
        <button class="start-btn" onclick="startGame(1)">Level 1</button>
        <button class="start-btn" onclick="startGame(2)">Level 2</button>
        <button class="start-btn" onclick="startGame(3)">Level 3</button>
        <button class="start-btn" onclick="startGame(4)">Level 4</button>
        <button class="start-btn" onclick="startGame(5)">Level 5</button>
        <div class="difficulty-info">
            <strong>Level 1:</strong> Singles only<br>
            <strong>Level 2:</strong> Pairs and chains<br>
            <strong>Level 3:</strong> X-wing, Y-wing<br>
            <strong>Level 4:</strong> Forcing chains<br>
            <strong>Level 5:</strong> Trial and error
        </div>
    </div>

    <canvas id="gameCanvas" width="450" height="450"></canvas>
    <div id="statusDisplay">
        <div class="status-item time">
            <div class="status-label">Time</div>
            <div class="status-value" id="timeDisplay">0:00</div>
        </div>
        <div class="status-item">
            <div class="status-label">Filled</div>
            <div class="status-value" id="filledCount">0/81</div>
        </div>
        <div class="status-item difficulty">
            <div class="status-label">Difficulty</div>
            <div class="status-value" id="difficultyDisplay">--</div>
        </div>
    </div>

    <div id="configPanel" style="display:none;">
        <div class="config-row">
            <button class="new-game-btn" onclick="showTitleScreen()">New Game</button>
        </div>
    </div>

    <div id="controls">
        <strong>Click:</strong> Select cell | <strong>1-9:</strong> Enter number | <strong>Backspace/Delete/0:</strong> Clear cell | <strong>Arrow keys:</strong> Navigate
    </div>
    <div id="audioControls">
        <label><input type="checkbox" id="sfxToggle" checked> Sound Effects</label>
    </div>

    <script src="storage.js"></script>
    <script src="audio.js"></script>
    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CELL_SIZE = 50;
        const GRID_SIZE = 9;
        const BOX_SIZE = 3;
        const COLORS = {
            background: '#1a1a2e',
            cellBg: '#2a2a4a',
            cellBgSelected: '#3a3a6a',
            cellBgHighlight: '#2d2d52',
            cellBgError: '#4a2a3a',
            cellBgFixed: '#252540',
            gridLine: '#4a4a6a',
            boxLine: '#6a6a8a',
            numberFixed: '#888',
            numberUser: '#4ecdc4',
            numberError: '#ff6b6b',
            selected: '#4ecdc4',
            highlight: '#3a3a5a'
        };

        const DIFFICULTY_NAMES = ['Blank', 'Level 1', 'Level 2', 'Level 3', 'Level 4', 'Level 5'];

        // ============================================
        // PERSISTENCE
        // ============================================
        const GAME_ID = 'sudoku';
        let gameData = GameStorage.load(GAME_ID, {
            bestTimes: {},
            gamesPlayed: 0,
            gamesWon: 0,
            sfxEnabled: true
        });

        function saveGameData() {
            GameStorage.save(GAME_ID, gameData);
        }

        // ============================================
        // DOM ELEMENTS
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const timeDisplayEl = document.getElementById('timeDisplay');
        const filledCountEl = document.getElementById('filledCount');
        const difficultyDisplayEl = document.getElementById('difficultyDisplay');
        const titleScreen = document.getElementById('titleScreen');
        const statusDisplay = document.getElementById('statusDisplay');
        const configPanel = document.getElementById('configPanel');

        // ============================================
        // GAME STATE
        // ============================================
        let grid = [];           // Current player grid
        let fixedCells = [];     // Which cells are part of the puzzle (not editable)
        let solution = [];       // The complete solution
        let selectedCell = { x: -1, y: -1 };
        let isPlaying = false;
        let currentDifficulty = 0;
        let startTime = 0;
        let elapsedTime = 0;
        let timerInterval = null;
        let gameWon = false;

        // ============================================
        // SUDOKU LOGIC
        // ============================================

        // Check if placing num at (row, col) is valid
        function isValidPlacement(board, row, col, num) {
            // Check row
            for (let c = 0; c < 9; c++) {
                if (c !== col && board[row][c] === num) return false;
            }
            // Check column
            for (let r = 0; r < 9; r++) {
                if (r !== row && board[r][col] === num) return false;
            }
            // Check 3x3 box
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            for (let r = boxRow; r < boxRow + 3; r++) {
                for (let c = boxCol; c < boxCol + 3; c++) {
                    if ((r !== row || c !== col) && board[r][c] === num) return false;
                }
            }
            return true;
        }

        // Get candidates for a cell
        function getCandidates(board, row, col) {
            if (board[row][col] !== 0) return [];
            const candidates = [];
            for (let num = 1; num <= 9; num++) {
                if (isValidPlacement(board, row, col, num)) {
                    candidates.push(num);
                }
            }
            return candidates;
        }

        // ============================================
        // SUDOKU SOLVER WITH TECHNIQUE CLASSIFICATION
        // ============================================

        // Level 1: Naked singles only
        function solveNakedSingles(board) {
            let changed = true;
            while (changed) {
                changed = false;
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (board[r][c] === 0) {
                            const candidates = getCandidates(board, r, c);
                            if (candidates.length === 1) {
                                board[r][c] = candidates[0];
                                changed = true;
                            }
                        }
                    }
                }
            }
            return board;
        }

        // Level 2: Hidden singles (number appears only once in row/col/box candidates)
        function solveHiddenSingles(board) {
            let changed = true;
            while (changed) {
                changed = false;
                // First try naked singles
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (board[r][c] === 0) {
                            const candidates = getCandidates(board, r, c);
                            if (candidates.length === 1) {
                                board[r][c] = candidates[0];
                                changed = true;
                            }
                        }
                    }
                }
                if (changed) continue;

                // Hidden singles in rows
                for (let r = 0; r < 9; r++) {
                    for (let num = 1; num <= 9; num++) {
                        let positions = [];
                        for (let c = 0; c < 9; c++) {
                            if (board[r][c] === 0 && getCandidates(board, r, c).includes(num)) {
                                positions.push(c);
                            }
                        }
                        if (positions.length === 1) {
                            board[r][positions[0]] = num;
                            changed = true;
                        }
                    }
                }

                // Hidden singles in columns
                for (let c = 0; c < 9; c++) {
                    for (let num = 1; num <= 9; num++) {
                        let positions = [];
                        for (let r = 0; r < 9; r++) {
                            if (board[r][c] === 0 && getCandidates(board, r, c).includes(num)) {
                                positions.push(r);
                            }
                        }
                        if (positions.length === 1) {
                            board[positions[0]][c] = num;
                            changed = true;
                        }
                    }
                }

                // Hidden singles in boxes
                for (let boxR = 0; boxR < 3; boxR++) {
                    for (let boxC = 0; boxC < 3; boxC++) {
                        for (let num = 1; num <= 9; num++) {
                            let positions = [];
                            for (let r = boxR * 3; r < boxR * 3 + 3; r++) {
                                for (let c = boxC * 3; c < boxC * 3 + 3; c++) {
                                    if (board[r][c] === 0 && getCandidates(board, r, c).includes(num)) {
                                        positions.push({ r, c });
                                    }
                                }
                            }
                            if (positions.length === 1) {
                                board[positions[0].r][positions[0].c] = num;
                                changed = true;
                            }
                        }
                    }
                }
            }
            return board;
        }

        // Full backtracking solver (Level 5)
        function solveBacktracking(board) {
            const copy = board.map(row => [...row]);
            if (solveBacktrackingHelper(copy)) {
                return copy;
            }
            return null;
        }

        function solveBacktrackingHelper(board) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) {
                        const candidates = getCandidates(board, r, c);
                        for (const num of candidates) {
                            board[r][c] = num;
                            if (solveBacktrackingHelper(board)) {
                                return true;
                            }
                            board[r][c] = 0;
                        }
                        return false;
                    }
                }
            }
            return true;
        }

        // Check if puzzle is solved
        function isSolved(board) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) return false;
                }
            }
            return true;
        }

        // Determine difficulty level of a puzzle
        function getDifficultyLevel(puzzle) {
            // Try Level 1 (naked singles only)
            let test = puzzle.map(row => [...row]);
            solveNakedSingles(test);
            if (isSolved(test)) return 1;

            // Try Level 2 (hidden singles)
            test = puzzle.map(row => [...row]);
            solveHiddenSingles(test);
            if (isSolved(test)) return 2;

            // Levels 3-5 require more advanced techniques
            // For simplicity, we'll use backtracking count as a proxy
            test = puzzle.map(row => [...row]);
            const backtrackCount = countBacktracks(test);

            if (backtrackCount < 10) return 3;
            if (backtrackCount < 50) return 4;
            return 5;
        }

        function countBacktracks(board) {
            let count = 0;
            const copy = board.map(row => [...row]);

            function solve() {
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (copy[r][c] === 0) {
                            const candidates = getCandidates(copy, r, c);
                            for (const num of candidates) {
                                copy[r][c] = num;
                                if (solve()) return true;
                                copy[r][c] = 0;
                                count++;
                            }
                            return false;
                        }
                    }
                }
                return true;
            }

            solve();
            return count;
        }

        // ============================================
        // PUZZLE GENERATION
        // ============================================

        // Generate a complete valid Sudoku grid
        function generateCompleteSudoku() {
            const board = Array(9).fill(null).map(() => Array(9).fill(0));
            fillBoard(board);
            return board;
        }

        function fillBoard(board) {
            const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) {
                        const shuffled = [...nums].sort(() => Math.random() - 0.5);
                        for (const num of shuffled) {
                            if (isValidPlacement(board, r, c, num)) {
                                board[r][c] = num;
                                if (fillBoard(board)) return true;
                                board[r][c] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }

        // Generate puzzle by removing cells from complete grid
        function generatePuzzle(targetDifficulty) {
            const complete = generateCompleteSudoku();
            const puzzle = complete.map(row => [...row]);

            // Create list of all positions and shuffle
            const positions = [];
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    positions.push({ r, c });
                }
            }
            positions.sort(() => Math.random() - 0.5);

            // Target number of clues based on difficulty
            const targetClues = {
                1: 45,  // Easy - more clues
                2: 36,
                3: 32,
                4: 28,
                5: 24   // Hard - fewer clues
            };

            let currentClues = 81;
            const minClues = targetClues[targetDifficulty] || 30;

            for (const pos of positions) {
                if (currentClues <= minClues) break;

                const backup = puzzle[pos.r][pos.c];
                puzzle[pos.r][pos.c] = 0;

                // Check if puzzle still has unique solution
                const test = puzzle.map(row => [...row]);
                const solved = solveBacktracking(test);

                if (solved) {
                    // Verify it matches our complete solution
                    let matches = true;
                    for (let r = 0; r < 9; r++) {
                        for (let c = 0; c < 9; c++) {
                            if (test[r][c] !== complete[r][c]) {
                                matches = false;
                                break;
                            }
                        }
                        if (!matches) break;
                    }

                    if (matches) {
                        const difficulty = getDifficultyLevel(puzzle);
                        if (difficulty <= targetDifficulty) {
                            currentClues--;
                        } else {
                            // Restore if too hard
                            puzzle[pos.r][pos.c] = backup;
                        }
                    } else {
                        // Multiple solutions, restore
                        puzzle[pos.r][pos.c] = backup;
                    }
                } else {
                    puzzle[pos.r][pos.c] = backup;
                }
            }

            return { puzzle, solution: complete };
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateDisplays() {
            timeDisplayEl.textContent = formatTime(elapsedTime);

            let filled = 0;
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (grid[r][c] !== 0) filled++;
                }
            }
            filledCountEl.textContent = `${filled}/81`;
            difficultyDisplayEl.textContent = DIFFICULTY_NAMES[currentDifficulty];
        }

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                elapsedTime = Math.floor((Date.now() - startTime) / 1000);
                updateDisplays();
            }, 1000);
        }

        function showTitleScreen() {
            clearInterval(timerInterval);
            isPlaying = false;
            gameWon = false;
            titleScreen.style.display = 'block';
            canvas.classList.remove('visible');
            statusDisplay.classList.remove('visible');
            configPanel.style.display = 'none';
        }

        // ============================================
        // GAME FUNCTIONS
        // ============================================

        function startGame(difficulty) {
            AudioSystem.unlock();
            currentDifficulty = difficulty;

            if (difficulty === 0) {
                // Blank grid
                grid = Array(9).fill(null).map(() => Array(9).fill(0));
                fixedCells = Array(9).fill(null).map(() => Array(9).fill(false));
                solution = null;
            } else {
                // Generate puzzle
                const { puzzle, solution: sol } = generatePuzzle(difficulty);
                grid = puzzle.map(row => [...row]);
                solution = sol;
                fixedCells = puzzle.map(row => row.map(cell => cell !== 0));
            }

            selectedCell = { x: -1, y: -1 };
            gameWon = false;
            clearInterval(timerInterval);
            elapsedTime = 0;
            isPlaying = true;

            titleScreen.style.display = 'none';
            canvas.classList.add('visible');
            statusDisplay.classList.add('visible');
            configPanel.style.display = 'block';

            startTimer();
            updateDisplays();
            render();
        }

        function checkWin() {
            // Check if all cells are filled
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (grid[r][c] === 0) return false;
                }
            }

            // Validate all placements
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (!isValidPlacement(grid, r, c, grid[r][c])) {
                        return false;
                    }
                }
            }

            return true;
        }

        function handleWin() {
            clearInterval(timerInterval);
            gameWon = true;
            isPlaying = false;

            AudioSystem.sfx.levelComplete();

            if (currentDifficulty > 0) {
                const key = `level${currentDifficulty}`;
                if (!gameData.bestTimes[key] || elapsedTime < gameData.bestTimes[key]) {
                    gameData.bestTimes[key] = elapsedTime;
                }
                gameData.gamesWon++;
            }
            gameData.gamesPlayed++;
            saveGameData();

            render();
        }

        // ============================================
        // RENDERING
        // ============================================

        function render() {
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw cells
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    renderCell(r, c);
                }
            }

            // Draw grid lines
            ctx.strokeStyle = COLORS.gridLine;
            ctx.lineWidth = 1;
            for (let i = 0; i <= 9; i++) {
                // Horizontal
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
                // Vertical
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.stroke();
            }

            // Draw box lines (thicker)
            ctx.strokeStyle = COLORS.boxLine;
            ctx.lineWidth = 3;
            for (let i = 0; i <= 3; i++) {
                // Horizontal
                ctx.beginPath();
                ctx.moveTo(0, i * 3 * CELL_SIZE);
                ctx.lineTo(canvas.width, i * 3 * CELL_SIZE);
                ctx.stroke();
                // Vertical
                ctx.beginPath();
                ctx.moveTo(i * 3 * CELL_SIZE, 0);
                ctx.lineTo(i * 3 * CELL_SIZE, canvas.height);
                ctx.stroke();
            }

            // Draw selection
            if (selectedCell.x >= 0 && selectedCell.y >= 0) {
                ctx.strokeStyle = COLORS.selected;
                ctx.lineWidth = 3;
                ctx.strokeRect(
                    selectedCell.x * CELL_SIZE + 2,
                    selectedCell.y * CELL_SIZE + 2,
                    CELL_SIZE - 4,
                    CELL_SIZE - 4
                );
            }

            // Draw win overlay
            if (gameWon) {
                renderWinOverlay();
            }
        }

        function renderCell(row, col) {
            const x = col * CELL_SIZE;
            const y = row * CELL_SIZE;
            const value = grid[row][col];
            const isFixed = fixedCells[row][col];
            const isSelected = selectedCell.x === col && selectedCell.y === row;

            // Determine cell background
            let bgColor = COLORS.cellBg;
            if (isFixed) {
                bgColor = COLORS.cellBgFixed;
            } else if (isSelected) {
                bgColor = COLORS.cellBgSelected;
            }

            // Check for errors (duplicate in row/col/box)
            let hasError = false;
            if (value !== 0 && !isValidPlacement(grid, row, col, value)) {
                hasError = true;
                bgColor = COLORS.cellBgError;
            }

            // Highlight same number
            if (selectedCell.x >= 0 && selectedCell.y >= 0) {
                const selectedValue = grid[selectedCell.y][selectedCell.x];
                if (selectedValue !== 0 && value === selectedValue && !isSelected) {
                    bgColor = COLORS.cellBgHighlight;
                }
            }

            ctx.fillStyle = bgColor;
            ctx.fillRect(x + 1, y + 1, CELL_SIZE - 2, CELL_SIZE - 2);

            // Draw number
            if (value !== 0) {
                ctx.font = 'bold 28px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (hasError) {
                    ctx.fillStyle = COLORS.numberError;
                } else if (isFixed) {
                    ctx.fillStyle = COLORS.numberFixed;
                } else {
                    ctx.fillStyle = COLORS.numberUser;
                }

                ctx.fillText(value.toString(), x + CELL_SIZE / 2, y + CELL_SIZE / 2 + 2);
            }
        }

        function renderWinOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 48px Courier New';
            ctx.fillText('SOLVED!', canvas.width / 2, canvas.height / 2 - 40);

            ctx.fillStyle = '#ffe66d';
            ctx.font = '24px Courier New';
            ctx.fillText(`Time: ${formatTime(elapsedTime)}`, canvas.width / 2, canvas.height / 2 + 20);

            ctx.fillStyle = '#888';
            ctx.font = '16px Courier New';
            ctx.fillText('Click New Game to play again', canvas.width / 2, canvas.height / 2 + 70);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        function getCellFromEvent(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;
            return {
                x: Math.floor(mx / CELL_SIZE),
                y: Math.floor(my / CELL_SIZE)
            };
        }

        canvas.addEventListener('click', (e) => {
            AudioSystem.unlock();

            if (gameWon) return;
            if (!isPlaying) return;

            const cell = getCellFromEvent(e);
            if (cell.x >= 0 && cell.x < 9 && cell.y >= 0 && cell.y < 9) {
                selectedCell = cell;
                AudioSystem.sfx.select();
                render();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (!isPlaying || gameWon) return;
            if (selectedCell.x < 0 || selectedCell.y < 0) return;

            const { x, y } = selectedCell;

            // Arrow key navigation
            if (e.key === 'ArrowUp' && y > 0) {
                selectedCell.y--;
                AudioSystem.sfx.select();
                render();
                e.preventDefault();
                return;
            }
            if (e.key === 'ArrowDown' && y < 8) {
                selectedCell.y++;
                AudioSystem.sfx.select();
                render();
                e.preventDefault();
                return;
            }
            if (e.key === 'ArrowLeft' && x > 0) {
                selectedCell.x--;
                AudioSystem.sfx.select();
                render();
                e.preventDefault();
                return;
            }
            if (e.key === 'ArrowRight' && x < 8) {
                selectedCell.x++;
                AudioSystem.sfx.select();
                render();
                e.preventDefault();
                return;
            }

            // Don't allow editing fixed cells
            if (fixedCells[y][x]) {
                return;
            }

            // Number input (1-9)
            const num = parseInt(e.key);
            if (num >= 1 && num <= 9) {
                // Check if this placement would be valid
                const oldValue = grid[y][x];
                grid[y][x] = 0; // Temporarily clear to check validity

                if (isValidPlacement(grid, y, x, num)) {
                    grid[y][x] = num;
                    AudioSystem.sfx.hit();

                    // Check for win
                    if (checkWin()) {
                        handleWin();
                    }
                } else {
                    // Invalid move - restore and play error sound
                    grid[y][x] = oldValue;
                    AudioSystem.sfx.death();
                }

                render();
                e.preventDefault();
                return;
            }

            // Clear cell (Backspace, Delete, or 0)
            if (e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') {
                grid[y][x] = 0;
                AudioSystem.sfx.select();
                render();
                e.preventDefault();
                return;
            }
        });

        // ============================================
        // AUDIO CONTROLS
        // ============================================
        document.getElementById('sfxToggle').addEventListener('change', (e) => {
            AudioSystem.sfxEnabled = e.target.checked;
            gameData.sfxEnabled = e.target.checked;
            saveGameData();
        });

        AudioSystem.sfxEnabled = gameData.sfxEnabled;
        document.getElementById('sfxToggle').checked = gameData.sfxEnabled;

        // ============================================
        // INITIALIZE
        // ============================================
        console.log('Sudoku initialized');
    </script>
</body>
</html>
