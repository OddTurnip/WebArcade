<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer</title>
    <link rel="icon" type="image/x-icon" href="https://oddturnip.com/favicon_turnip.ico">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #eee;
        }
        h1 { margin-bottom: 10px; color: #ff6b6b; }
        #gameCanvas {
            border: 4px solid #4a4a6a;
            border-radius: 4px;
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #scoreDisplay {
            margin-top: 15px;
            padding: 10px 20px;
            background: #2a2a4a;
            border-radius: 4px;
            display: flex;
            gap: 40px;
            justify-content: center;
        }
        .score-item { text-align: center; }
        .score-label { font-size: 12px; color: #888; margin-bottom: 5px; }
        .score-value { font-size: 24px; color: #4ecdc4; }
        .high-score .score-value { color: #ffe66d; }
        #controls {
            margin-top: 15px;
            font-size: 11px;
            color: #888;
            text-align: center;
            max-width: 500px;
            line-height: 1.6;
        }
        #audioControls {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        #audioControls label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #audioControls input[type="checkbox"] {
            cursor: pointer;
            accent-color: #4ecdc4;
        }
    </style>
</head>
<body>
    <h1>Platformer</h1>
    <canvas id="gameCanvas" width="640" height="480"></canvas>
    <div id="scoreDisplay">
        <div class="score-item">
            <div class="score-label">Score</div>
            <div class="score-value" id="currentScore">0</div>
        </div>
        <div class="score-item high-score">
            <div class="score-label">High Score</div>
            <div class="score-value" id="highScore">0</div>
        </div>
    </div>
    <div id="controls">
        <strong>Keyboard:</strong> Left/Right or A/D to move | Space/Z to jump | Esc to pause<br>
        <strong>Controller:</strong> D-Pad / Left Stick to move | A to jump | Start to pause
    </div>
    <div id="audioControls">
        <label><input type="checkbox" id="musicToggle" checked> Music</label>
        <label><input type="checkbox" id="sfxToggle" checked> Sound Effects</label>
    </div>

    <script src="controller.js"></script>
    <script src="audio.js"></script>
    <script src="storage.js"></script>
    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            WIDTH: 640,
            HEIGHT: 480,
            TILE_SIZE: 32,
            GRAVITY: 0.6,
            MAX_FALL_SPEED: 12,
            PLAYER_SPEED: 4,
            PLAYER_JUMP: -12,
            ENEMY_SPEED: 1.5,
            COLORS: {
                sky: '#5c94fc',
                skyGradient: '#9290ff',
                ground: '#c84c0c',
                groundHighlight: '#fc9838',
                groundDark: '#a02800',
                brick: '#c84c0c',
                brickHighlight: '#fc9838',
                block: '#fcbcb0',
                blockShade: '#d89880',
                player: '#ff6b6b',
                playerShirt: '#4ecdc4',
                enemy: '#d8a060',
                enemyDark: '#a07848',
                goal: '#ffe66d',
                goalPole: '#8b8b8b',
                cloud: '#ffffff',
                bush: '#00a800',
                bushDark: '#008000',
                hill: '#00d800',
                hillDark: '#00a800',
                text: '#ffffff',
                textHighlight: '#ffe66d'
            }
        };

        // Tile types
        const TILE = {
            EMPTY: 0,
            GROUND: 1,
            BRICK: 2,
            BLOCK: 3,
            GOAL: 4,
            PIT: 5  // Invisible death zone below ground level
        };

        // Calculate visible tiles
        const TILES_X = Math.ceil(CONFIG.WIDTH / CONFIG.TILE_SIZE) + 1;
        const TILES_Y = Math.ceil(CONFIG.HEIGHT / CONFIG.TILE_SIZE);

        // ============================================
        // LEVEL DATA
        // ============================================
        // Level is 100 tiles wide, 15 tiles tall
        // 0 = empty, 1 = ground, 2 = brick, 3 = block, 4 = goal, 5 = pit
        const LEVEL_WIDTH = 100;
        const LEVEL_HEIGHT = 15;

        function createLevel() {
            // Create empty level
            const level = [];
            for (let y = 0; y < LEVEL_HEIGHT; y++) {
                level[y] = [];
                for (let x = 0; x < LEVEL_WIDTH; x++) {
                    level[y][x] = TILE.EMPTY;
                }
            }

            // Fill ground (bottom 2 rows)
            for (let x = 0; x < LEVEL_WIDTH; x++) {
                level[LEVEL_HEIGHT - 1][x] = TILE.GROUND;
                level[LEVEL_HEIGHT - 2][x] = TILE.GROUND;
            }

            // Add pits (gaps in ground)
            const pits = [
                { x: 20, width: 3 },
                { x: 35, width: 2 },
                { x: 55, width: 4 },
                { x: 75, width: 3 }
            ];
            for (const pit of pits) {
                for (let px = pit.x; px < pit.x + pit.width; px++) {
                    level[LEVEL_HEIGHT - 1][px] = TILE.PIT;
                    level[LEVEL_HEIGHT - 2][px] = TILE.PIT;
                }
            }

            // Add platforms (brick blocks)
            const platforms = [
                { x: 15, y: 10, width: 4 },
                { x: 25, y: 9, width: 3 },
                { x: 32, y: 11, width: 5 },
                { x: 45, y: 10, width: 3 },
                { x: 50, y: 8, width: 4 },
                { x: 60, y: 10, width: 6 },
                { x: 70, y: 9, width: 3 },
                { x: 80, y: 10, width: 4 },
                { x: 85, y: 8, width: 3 }
            ];
            for (const plat of platforms) {
                for (let px = plat.x; px < plat.x + plat.width; px++) {
                    level[plat.y][px] = TILE.BRICK;
                }
            }

            // Add question blocks / solid blocks
            const blocks = [
                { x: 12, y: 9 },
                { x: 28, y: 6 },
                { x: 42, y: 9 },
                { x: 48, y: 9 },
                { x: 65, y: 7 },
                { x: 78, y: 9 }
            ];
            for (const block of blocks) {
                level[block.y][block.x] = TILE.BLOCK;
            }

            // Add stairs near the end
            for (let i = 0; i < 5; i++) {
                for (let y = LEVEL_HEIGHT - 3; y >= LEVEL_HEIGHT - 3 - i; y--) {
                    level[y][90 + i] = TILE.GROUND;
                }
            }

            // Goal flag at end
            level[LEVEL_HEIGHT - 3][97] = TILE.GOAL;

            return level;
        }

        // Enemy spawn positions (x tile position)
        const ENEMY_SPAWNS = [18, 30, 40, 52, 68, 82];

        // ============================================
        // PERSISTENCE
        // ============================================
        const GAME_ID = 'platformer';
        let gameData = GameStorage.load(GAME_ID, GameStorage.defaults.arcade());

        function saveGameData() {
            GameStorage.save(GAME_ID, gameData);
        }

        // ============================================
        // GAME STATE
        // ============================================
        const GameState = {
            TITLE: 'title',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'game_over',
            LEVEL_COMPLETE: 'level_complete'
        };

        let state = GameState.TITLE;
        let score = 0;
        let isNewHighScore = false;
        let level = [];
        let cameraX = 0;
        let maxCameraX = 0; // For no-backtracking
        let pauseTime = 0;
        const UNPAUSE_DELAY = 250;

        // Player state
        const player = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            width: 24,
            height: 30,
            onGround: false,
            facing: 1, // 1 = right, -1 = left
            animFrame: 0,
            animTimer: 0
        };

        // Enemies array
        let enemies = [];

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        const currentScoreEl = document.getElementById('currentScore');
        const highScoreEl = document.getElementById('highScore');

        // ============================================
        // INITIALIZATION
        // ============================================
        function initGame() {
            level = createLevel();
            score = 0;
            isNewHighScore = false;
            cameraX = 0;
            maxCameraX = 0;

            // Reset player
            player.x = 3 * CONFIG.TILE_SIZE;
            player.y = (LEVEL_HEIGHT - 3) * CONFIG.TILE_SIZE;
            player.vx = 0;
            player.vy = 0;
            player.onGround = false;
            player.facing = 1;
            player.animFrame = 0;
            player.animTimer = 0;

            // Spawn enemies
            enemies = [];
            for (const spawnX of ENEMY_SPAWNS) {
                enemies.push({
                    x: spawnX * CONFIG.TILE_SIZE,
                    y: (LEVEL_HEIGHT - 3) * CONFIG.TILE_SIZE,
                    vx: -CONFIG.ENEMY_SPEED,
                    width: 28,
                    height: 26,
                    alive: true,
                    squashTimer: 0
                });
            }

            updateDisplays();
        }

        function startGame() {
            AudioSystem.unlock();
            AudioSystem.sfx.select();
            initGame();
            state = GameState.PLAYING;
            AudioSystem.music.start('bounce');
        }

        function updateDisplays() {
            currentScoreEl.textContent = score;
            highScoreEl.textContent = gameData.highScore;
        }

        // ============================================
        // COLLISION DETECTION
        // ============================================
        function getTileAt(pixelX, pixelY) {
            const tileX = Math.floor(pixelX / CONFIG.TILE_SIZE);
            const tileY = Math.floor(pixelY / CONFIG.TILE_SIZE);
            if (tileX < 0 || tileX >= LEVEL_WIDTH || tileY < 0 || tileY >= LEVEL_HEIGHT) {
                return tileY >= LEVEL_HEIGHT ? TILE.PIT : TILE.EMPTY;
            }
            return level[tileY][tileX];
        }

        function isSolidTile(tile) {
            return tile === TILE.GROUND || tile === TILE.BRICK || tile === TILE.BLOCK;
        }

        function checkCollision(x, y, width, height) {
            // Check all four corners and middle points
            const points = [
                { x: x + 2, y: y + 2 },           // top-left
                { x: x + width - 2, y: y + 2 },   // top-right
                { x: x + 2, y: y + height - 2 }, // bottom-left
                { x: x + width - 2, y: y + height - 2 }, // bottom-right
                { x: x + width / 2, y: y + 2 },   // top-center
                { x: x + width / 2, y: y + height - 2 } // bottom-center
            ];

            for (const point of points) {
                if (isSolidTile(getTileAt(point.x, point.y))) {
                    return true;
                }
            }
            return false;
        }

        function isOnGround(x, y, width, height) {
            // Check if there's solid ground just below the player's feet
            // Check 3 points along the bottom edge, 1 pixel below
            const groundY = y + height + 1;
            return isSolidTile(getTileAt(x + 4, groundY)) ||
                   isSolidTile(getTileAt(x + width / 2, groundY)) ||
                   isSolidTile(getTileAt(x + width - 4, groundY));
        }

        // ============================================
        // UPDATE FUNCTIONS
        // ============================================
        function updateTitle() {
            if (GameController.anyButtonJustPressed()) {
                startGame();
            }
        }

        function updatePlaying() {
            // Pause check
            if (GameController.justPressed('start')) {
                pauseTime = Date.now();
                state = GameState.PAUSED;
                AudioSystem.music.stop();
                return;
            }

            // Player horizontal movement
            player.vx = 0;
            if (GameController.direction.left) {
                player.vx = -CONFIG.PLAYER_SPEED;
                player.facing = -1;
            }
            if (GameController.direction.right) {
                player.vx = CONFIG.PLAYER_SPEED;
                player.facing = 1;
            }

            // Prevent backtracking
            const minPlayerX = maxCameraX + 8;
            if (player.x + player.vx < minPlayerX) {
                player.vx = 0;
                player.x = minPlayerX;
            }

            // Check if on ground before applying physics
            player.onGround = isOnGround(player.x, player.y, player.width, player.height);

            // Jumping
            if (GameController.justPressed('a') && player.onGround) {
                player.vy = CONFIG.PLAYER_JUMP;
                player.onGround = false;
                AudioSystem.sfx.select();
            }

            // Apply gravity
            player.vy += CONFIG.GRAVITY;
            if (player.vy > CONFIG.MAX_FALL_SPEED) {
                player.vy = CONFIG.MAX_FALL_SPEED;
            }

            // Horizontal movement with collision
            const newX = player.x + player.vx;
            if (!checkCollision(newX, player.y, player.width, player.height)) {
                player.x = newX;
            }

            // Vertical movement with collision
            const newY = player.y + player.vy;

            if (player.vy > 0) {
                // Moving down - check for ground
                if (checkCollision(player.x, newY, player.width, player.height)) {
                    // Snap to tile boundary
                    player.y = Math.floor((newY + player.height) / CONFIG.TILE_SIZE) * CONFIG.TILE_SIZE - player.height;
                    player.vy = 0;
                } else {
                    player.y = newY;
                }
            } else if (player.vy < 0) {
                // Moving up - check for ceiling
                if (checkCollision(player.x, newY, player.width, player.height)) {
                    player.y = Math.floor(newY / CONFIG.TILE_SIZE) * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE;
                    player.vy = 0;
                    AudioSystem.sfx.wallHit();
                } else {
                    player.y = newY;
                }
            }

            // Check for pit death
            if (player.y > LEVEL_HEIGHT * CONFIG.TILE_SIZE) {
                playerDeath();
                return;
            }

            // Check for goal
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            if (getTileAt(playerCenterX, playerCenterY) === TILE.GOAL) {
                levelComplete();
                return;
            }

            // Update camera (follows player, can't go back)
            const targetCameraX = player.x - CONFIG.WIDTH / 3;
            cameraX = Math.max(maxCameraX, Math.min(targetCameraX, (LEVEL_WIDTH - TILES_X) * CONFIG.TILE_SIZE));
            maxCameraX = cameraX;

            // Animation
            if (Math.abs(player.vx) > 0 && player.onGround) {
                player.animTimer++;
                if (player.animTimer >= 8) {
                    player.animTimer = 0;
                    player.animFrame = (player.animFrame + 1) % 3;
                }
            } else if (!player.onGround) {
                player.animFrame = 1; // Jump frame
            } else {
                player.animFrame = 0;
            }

            // Update enemies
            updateEnemies();

            // Check player-enemy collisions
            checkEnemyCollisions();
        }

        function updateEnemies() {
            for (const enemy of enemies) {
                if (!enemy.alive) {
                    if (enemy.squashTimer > 0) {
                        enemy.squashTimer--;
                    }
                    continue;
                }

                // Move enemy
                const newEX = enemy.x + enemy.vx;

                // Check wall collision
                const checkY = enemy.y + enemy.height / 2;
                const frontX = enemy.vx < 0 ? newEX : newEX + enemy.width;
                if (isSolidTile(getTileAt(frontX, checkY))) {
                    enemy.vx = -enemy.vx; // Reverse direction
                } else {
                    // Check for ledge (don't walk off platforms)
                    const groundCheckX = enemy.vx < 0 ? newEX : newEX + enemy.width;
                    const groundCheckY = enemy.y + enemy.height + 4;
                    if (!isSolidTile(getTileAt(groundCheckX, groundCheckY))) {
                        enemy.vx = -enemy.vx; // Reverse at ledge
                    } else {
                        enemy.x = newEX;
                    }
                }

                // Apply gravity to enemy
                const enemyGroundCheck = enemy.y + enemy.height + 1;
                if (!isSolidTile(getTileAt(enemy.x + enemy.width / 2, enemyGroundCheck))) {
                    enemy.y += 4; // Fall
                }
            }
        }

        function checkEnemyCollisions() {
            for (const enemy of enemies) {
                if (!enemy.alive) continue;

                // Check collision with player
                const playerRight = player.x + player.width;
                const playerBottom = player.y + player.height;
                const enemyRight = enemy.x + enemy.width;
                const enemyBottom = enemy.y + enemy.height;

                // AABB collision
                if (player.x < enemyRight &&
                    playerRight > enemy.x &&
                    player.y < enemyBottom &&
                    playerBottom > enemy.y) {

                    // Check if player is stomping (falling onto enemy)
                    const playerFeetY = playerBottom;
                    const enemyHeadY = enemy.y + enemy.height * 0.3;

                    if (player.vy > 0 && playerFeetY < enemyHeadY + 10) {
                        // Stomp! Kill enemy
                        enemy.alive = false;
                        enemy.squashTimer = 20;
                        player.vy = CONFIG.PLAYER_JUMP * 0.6; // Bounce
                        score += 100;
                        updateDisplays();
                        AudioSystem.sfx.hit();
                    } else {
                        // Player hit from side - death
                        playerDeath();
                        return;
                    }
                }
            }
        }

        function playerDeath() {
            AudioSystem.music.stop();
            AudioSystem.sfx.death();

            if (score > gameData.highScore) {
                gameData.highScore = score;
                isNewHighScore = gameData.gamesPlayed > 0;
            }
            gameData.gamesPlayed++;
            saveGameData();
            updateDisplays();

            state = GameState.GAME_OVER;
        }

        function levelComplete() {
            AudioSystem.music.stop();
            AudioSystem.sfx.levelComplete();

            score += 1000; // Completion bonus

            if (score > gameData.highScore) {
                gameData.highScore = score;
                isNewHighScore = gameData.gamesPlayed > 0;
            }
            gameData.gamesPlayed++;
            saveGameData();
            updateDisplays();

            state = GameState.LEVEL_COMPLETE;
        }

        function updatePaused() {
            if (Date.now() - pauseTime >= UNPAUSE_DELAY) {
                if (GameController.justPressed('start')) {
                    state = GameState.PLAYING;
                    AudioSystem.music.start('bounce');
                }
            }
        }

        function updateGameOver() {
            if (GameController.anyButtonJustPressed()) {
                state = GameState.TITLE;
            }
        }

        function updateLevelComplete() {
            if (GameController.anyButtonJustPressed()) {
                state = GameState.TITLE;
            }
        }

        // ============================================
        // RENDER FUNCTIONS
        // ============================================
        function renderBackground() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.HEIGHT);
            gradient.addColorStop(0, CONFIG.COLORS.skyGradient);
            gradient.addColorStop(1, CONFIG.COLORS.sky);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Draw clouds (parallax)
            const cloudOffset = -cameraX * 0.3;
            drawCloud(100 + cloudOffset % 800, 60);
            drawCloud(350 + cloudOffset % 800, 90);
            drawCloud(600 + cloudOffset % 800, 50);
            drawCloud(850 + cloudOffset % 800, 80);

            // Draw hills (parallax)
            const hillOffset = -cameraX * 0.5;
            drawHill(50 + hillOffset % 600, CONFIG.HEIGHT - 64, 80);
            drawHill(300 + hillOffset % 600, CONFIG.HEIGHT - 64, 60);
            drawHill(500 + hillOffset % 600, CONFIG.HEIGHT - 64, 100);
        }

        function drawCloud(x, y) {
            ctx.fillStyle = CONFIG.COLORS.cloud;
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 25, y - 5, 25, 0, Math.PI * 2);
            ctx.arc(x + 50, y, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawHill(x, y, width) {
            ctx.fillStyle = CONFIG.COLORS.hill;
            ctx.beginPath();
            ctx.moveTo(x - width, y);
            ctx.quadraticCurveTo(x, y - width * 0.6, x + width, y);
            ctx.fill();
            // Darker edge
            ctx.fillStyle = CONFIG.COLORS.hillDark;
            ctx.beginPath();
            ctx.moveTo(x - width, y);
            ctx.quadraticCurveTo(x - width * 0.3, y - width * 0.4, x, y);
            ctx.fill();
        }

        function renderTiles() {
            const startTile = Math.floor(cameraX / CONFIG.TILE_SIZE);
            const endTile = startTile + TILES_X + 1;

            for (let ty = 0; ty < LEVEL_HEIGHT; ty++) {
                for (let tx = startTile; tx < endTile && tx < LEVEL_WIDTH; tx++) {
                    if (tx < 0) continue;
                    const tile = level[ty][tx];
                    const screenX = tx * CONFIG.TILE_SIZE - cameraX;
                    const screenY = ty * CONFIG.TILE_SIZE;

                    switch (tile) {
                        case TILE.GROUND:
                            drawGroundTile(screenX, screenY, ty === LEVEL_HEIGHT - 2);
                            break;
                        case TILE.BRICK:
                            drawBrickTile(screenX, screenY);
                            break;
                        case TILE.BLOCK:
                            drawBlockTile(screenX, screenY);
                            break;
                        case TILE.GOAL:
                            drawGoalTile(screenX, screenY);
                            break;
                    }
                }
            }
        }

        function drawGroundTile(x, y, isTop) {
            const ts = CONFIG.TILE_SIZE;

            if (isTop) {
                // Top ground tile with grass
                ctx.fillStyle = CONFIG.COLORS.ground;
                ctx.fillRect(x, y + 4, ts, ts - 4);

                // Grass top
                ctx.fillStyle = CONFIG.COLORS.bush;
                ctx.fillRect(x, y, ts, 6);

                // Grass detail
                ctx.fillStyle = CONFIG.COLORS.bushDark;
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(x + i * 8 + 2, y + 6, 4, 2);
                }
            } else {
                // Underground tile
                ctx.fillStyle = CONFIG.COLORS.ground;
                ctx.fillRect(x, y, ts, ts);

                // Brick pattern
                ctx.fillStyle = CONFIG.COLORS.groundDark;
                ctx.fillRect(x, y + ts / 2 - 1, ts, 2);
                ctx.fillRect(x + ts / 2 - 1, y, 2, ts / 2);
                ctx.fillRect(x + ts / 4 - 1, y + ts / 2, 2, ts / 2);
                ctx.fillRect(x + ts * 3 / 4 - 1, y + ts / 2, 2, ts / 2);
            }
        }

        function drawBrickTile(x, y) {
            const ts = CONFIG.TILE_SIZE;

            // Main brick color
            ctx.fillStyle = CONFIG.COLORS.brick;
            ctx.fillRect(x, y, ts, ts);

            // Highlight
            ctx.fillStyle = CONFIG.COLORS.brickHighlight;
            ctx.fillRect(x, y, ts, 2);
            ctx.fillRect(x, y, 2, ts);

            // Dark edges
            ctx.fillStyle = CONFIG.COLORS.groundDark;
            ctx.fillRect(x + ts - 2, y, 2, ts);
            ctx.fillRect(x, y + ts - 2, ts, 2);

            // Brick lines
            ctx.fillStyle = CONFIG.COLORS.groundDark;
            ctx.fillRect(x, y + ts / 2 - 1, ts, 2);
            ctx.fillRect(x + ts / 2 - 1, y, 2, ts / 2);
            ctx.fillRect(x + ts / 4 - 1, y + ts / 2, 2, ts / 2);
            ctx.fillRect(x + ts * 3 / 4 - 1, y + ts / 2, 2, ts / 2);
        }

        function drawBlockTile(x, y) {
            const ts = CONFIG.TILE_SIZE;

            // Main color
            ctx.fillStyle = CONFIG.COLORS.block;
            ctx.fillRect(x, y, ts, ts);

            // Highlight
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(x + 2, y + 2, ts - 4, 3);
            ctx.fillRect(x + 2, y + 2, 3, ts - 4);

            // Shadow
            ctx.fillStyle = CONFIG.COLORS.blockShade;
            ctx.fillRect(x + ts - 5, y + 2, 3, ts - 4);
            ctx.fillRect(x + 2, y + ts - 5, ts - 4, 3);

            // Question mark or coin design
            ctx.fillStyle = CONFIG.COLORS.groundDark;
            ctx.fillRect(x + ts / 2 - 4, y + 8, 8, 3);
            ctx.fillRect(x + ts / 2 + 1, y + 11, 3, 4);
            ctx.fillRect(x + ts / 2 - 2, y + 15, 4, 3);
            ctx.fillRect(x + ts / 2 - 2, y + 21, 4, 3);
        }

        function drawGoalTile(x, y) {
            const ts = CONFIG.TILE_SIZE;

            // Flag pole
            ctx.fillStyle = CONFIG.COLORS.goalPole;
            ctx.fillRect(x + ts / 2 - 2, y - ts * 3, 4, ts * 4);

            // Pole top
            ctx.fillStyle = CONFIG.COLORS.goal;
            ctx.beginPath();
            ctx.arc(x + ts / 2, y - ts * 3, 6, 0, Math.PI * 2);
            ctx.fill();

            // Flag
            ctx.fillStyle = CONFIG.COLORS.goal;
            ctx.beginPath();
            ctx.moveTo(x + ts / 2 + 2, y - ts * 3 + 8);
            ctx.lineTo(x + ts / 2 + 24, y - ts * 3 + 18);
            ctx.lineTo(x + ts / 2 + 2, y - ts * 3 + 28);
            ctx.fill();

            // Flag shine
            ctx.fillStyle = '#fff8c0';
            ctx.beginPath();
            ctx.moveTo(x + ts / 2 + 4, y - ts * 3 + 12);
            ctx.lineTo(x + ts / 2 + 16, y - ts * 3 + 18);
            ctx.lineTo(x + ts / 2 + 4, y - ts * 3 + 24);
            ctx.fill();
        }

        function renderPlayer() {
            const screenX = player.x - cameraX;
            const screenY = player.y;

            ctx.save();

            // Flip if facing left
            if (player.facing === -1) {
                ctx.translate(screenX + player.width, screenY);
                ctx.scale(-1, 1);
                ctx.translate(0, 0);
            } else {
                ctx.translate(screenX, screenY);
            }

            // Body (shirt)
            ctx.fillStyle = CONFIG.COLORS.playerShirt;
            ctx.fillRect(4, 10, 16, 10);

            // Head
            ctx.fillStyle = '#ffd8b0';
            ctx.fillRect(6, 0, 12, 10);

            // Hat
            ctx.fillStyle = CONFIG.COLORS.player;
            ctx.fillRect(4, 0, 16, 4);
            ctx.fillRect(2, 4, 6, 3);

            // Eyes
            ctx.fillStyle = '#000000';
            ctx.fillRect(14, 4, 2, 2);

            // Legs
            ctx.fillStyle = CONFIG.COLORS.player;
            if (!player.onGround) {
                // Jumping pose
                ctx.fillRect(4, 20, 6, 10);
                ctx.fillRect(14, 20, 6, 10);
            } else if (player.animFrame === 1) {
                // Running frame 1
                ctx.fillRect(2, 20, 6, 10);
                ctx.fillRect(16, 20, 6, 10);
            } else if (player.animFrame === 2) {
                // Running frame 2
                ctx.fillRect(6, 20, 6, 10);
                ctx.fillRect(12, 20, 6, 10);
            } else {
                // Standing
                ctx.fillRect(5, 20, 6, 10);
                ctx.fillRect(13, 20, 6, 10);
            }

            ctx.restore();
        }

        function renderEnemies() {
            for (const enemy of enemies) {
                if (!enemy.alive && enemy.squashTimer <= 0) continue;

                const screenX = enemy.x - cameraX;
                const screenY = enemy.y;

                if (screenX < -50 || screenX > CONFIG.WIDTH + 50) continue;

                if (!enemy.alive) {
                    // Squashed enemy
                    ctx.fillStyle = CONFIG.COLORS.enemy;
                    ctx.fillRect(screenX + 2, screenY + enemy.height - 8, enemy.width - 4, 8);
                } else {
                    // Body
                    ctx.fillStyle = CONFIG.COLORS.enemy;
                    ctx.beginPath();
                    ctx.ellipse(screenX + enemy.width / 2, screenY + enemy.height / 2,
                               enemy.width / 2 - 2, enemy.height / 2 - 2, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Darker bottom
                    ctx.fillStyle = CONFIG.COLORS.enemyDark;
                    ctx.beginPath();
                    ctx.ellipse(screenX + enemy.width / 2, screenY + enemy.height - 6,
                               enemy.width / 2 - 4, 6, 0, 0, Math.PI);
                    ctx.fill();

                    // Eyes
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(screenX + 6, screenY + 6, 6, 6);
                    ctx.fillRect(screenX + enemy.width - 12, screenY + 6, 6, 6);

                    // Pupils (look in direction of movement)
                    ctx.fillStyle = '#000000';
                    const pupilOffset = enemy.vx < 0 ? 0 : 2;
                    ctx.fillRect(screenX + 6 + pupilOffset, screenY + 8, 3, 3);
                    ctx.fillRect(screenX + enemy.width - 12 + pupilOffset, screenY + 8, 3, 3);

                    // Feet (animated)
                    const footOffset = Math.floor(Date.now() / 150) % 2;
                    ctx.fillStyle = CONFIG.COLORS.enemyDark;
                    ctx.fillRect(screenX + 4 + footOffset * 2, screenY + enemy.height - 4, 8, 4);
                    ctx.fillRect(screenX + enemy.width - 12 - footOffset * 2, screenY + enemy.height - 4, 8, 4);
                }
            }
        }

        function renderTitle() {
            renderBackground();

            // Draw some sample tiles
            for (let i = 0; i < 20; i++) {
                drawGroundTile(i * CONFIG.TILE_SIZE, CONFIG.HEIGHT - CONFIG.TILE_SIZE, true);
            }

            // Darken
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Title
            ctx.fillStyle = CONFIG.COLORS.player;
            ctx.font = 'bold 56px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('PLATFORMER', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 - 80);

            // Subtitle
            ctx.fillStyle = CONFIG.COLORS.playerShirt;
            ctx.font = '18px "Courier New", monospace';
            ctx.fillText('Run, Jump, Survive!', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 - 40);

            // Instructions
            ctx.fillStyle = CONFIG.COLORS.textHighlight;
            ctx.font = '16px "Courier New", monospace';
            ctx.fillText('Press Any Button to Start', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 20);

            // Tips
            ctx.fillStyle = CONFIG.COLORS.text;
            ctx.font = '14px "Courier New", monospace';
            ctx.fillText('Jump on enemies to defeat them', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 60);
            ctx.fillText('Reach the flag to win!', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 85);

            // High score
            ctx.fillStyle = '#888';
            ctx.font = '14px "Courier New", monospace';
            ctx.fillText(`High Score: ${gameData.highScore}`, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 130);
        }

        function renderPlaying() {
            renderBackground();
            renderTiles();
            renderEnemies();
            renderPlayer();

            // Score display
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(10, 10, 120, 30);
            ctx.fillStyle = CONFIG.COLORS.text;
            ctx.font = '18px "Courier New", monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 20, 32);
        }

        function renderPaused() {
            renderPlaying();

            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = CONFIG.COLORS.textHighlight;
            ctx.font = 'bold 48px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2);

            ctx.fillStyle = CONFIG.COLORS.text;
            ctx.font = '18px "Courier New", monospace';
            ctx.fillText('Press Start to Resume', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 50);
        }

        function renderGameOver() {
            renderBackground();
            renderTiles();
            renderEnemies();

            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = CONFIG.COLORS.player;
            ctx.font = 'bold 48px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 - 40);

            ctx.fillStyle = CONFIG.COLORS.text;
            ctx.font = '24px "Courier New", monospace';
            ctx.fillText(`Score: ${score}`, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 20);

            if (isNewHighScore) {
                ctx.fillStyle = CONFIG.COLORS.textHighlight;
                ctx.font = 'bold 28px "Courier New", monospace';
                ctx.fillText('NEW HIGH SCORE!', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 60);
            }

            ctx.fillStyle = CONFIG.COLORS.textHighlight;
            ctx.font = '16px "Courier New", monospace';
            ctx.fillText('Press Any Button to Continue', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 110);
        }

        function renderLevelComplete() {
            renderBackground();
            renderTiles();
            renderPlayer();

            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = CONFIG.COLORS.goal;
            ctx.font = 'bold 48px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('LEVEL CLEAR!', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 - 50);

            ctx.fillStyle = CONFIG.COLORS.text;
            ctx.font = '24px "Courier New", monospace';
            ctx.fillText(`Score: ${score}`, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 10);

            if (isNewHighScore) {
                ctx.fillStyle = CONFIG.COLORS.textHighlight;
                ctx.font = 'bold 28px "Courier New", monospace';
                ctx.fillText('NEW HIGH SCORE!', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 50);
            }

            ctx.fillStyle = CONFIG.COLORS.textHighlight;
            ctx.font = '16px "Courier New", monospace';
            ctx.fillText('Press Any Button to Continue', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 110);
        }

        // ============================================
        // AUDIO CONTROLS
        // ============================================
        const musicToggle = document.getElementById('musicToggle');
        const sfxToggle = document.getElementById('sfxToggle');

        // Load audio preferences
        AudioSystem.musicEnabled = gameData.musicEnabled;
        AudioSystem.sfxEnabled = gameData.sfxEnabled;
        musicToggle.checked = gameData.musicEnabled;
        sfxToggle.checked = gameData.sfxEnabled;

        musicToggle.addEventListener('change', (e) => {
            AudioSystem.musicEnabled = e.target.checked;
            gameData.musicEnabled = e.target.checked;
            saveGameData();
            if (state === GameState.PLAYING) {
                if (e.target.checked) {
                    AudioSystem.music.start('bounce');
                } else {
                    AudioSystem.music.stop();
                }
            }
        });

        sfxToggle.addEventListener('change', (e) => {
            AudioSystem.sfxEnabled = e.target.checked;
            gameData.sfxEnabled = e.target.checked;
            saveGameData();
        });

        // Unlock audio
        const unlockAudio = () => {
            AudioSystem.unlock();
        };
        document.addEventListener('keydown', unlockAudio, { once: true });
        document.addEventListener('click', unlockAudio, { once: true });
        document.addEventListener('touchstart', unlockAudio, { once: true });

        canvas.addEventListener('click', () => {
            unlockAudio();
            if (state === GameState.TITLE || state === GameState.GAME_OVER || state === GameState.LEVEL_COMPLETE) {
                startGame();
            }
        });

        // ============================================
        // GAME LOOP
        // ============================================
        function gameLoop() {
            GameController.poll();

            switch (state) {
                case GameState.TITLE:
                    updateTitle();
                    renderTitle();
                    break;
                case GameState.PLAYING:
                    updatePlaying();
                    renderPlaying();
                    break;
                case GameState.PAUSED:
                    updatePaused();
                    renderPaused();
                    break;
                case GameState.GAME_OVER:
                    updateGameOver();
                    renderGameOver();
                    break;
                case GameState.LEVEL_COMPLETE:
                    updateLevelComplete();
                    renderLevelComplete();
                    break;
            }

            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // START
        // ============================================
        console.log('Platformer initialized');
        highScoreEl.textContent = gameData.highScore;
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
