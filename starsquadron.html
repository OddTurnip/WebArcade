<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Squadron</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            font-family: 'Courier New', monospace;
            color: #ffffff;
        }
        h1 {
            color: #ff6b6b;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
            margin-bottom: 15px;
            font-size: 28px;
            letter-spacing: 4px;
        }
        #gameCanvas {
            border: 4px solid #4a4a6a;
            border-radius: 4px;
            display: block;
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.3);
        }
        #scoreDisplay {
            display: flex;
            gap: 40px;
            margin-bottom: 15px;
            background: #2a2a4a;
            padding: 10px 30px;
            border-radius: 8px;
            border: 2px solid #4a4a6a;
        }
        .score-item {
            text-align: center;
        }
        .score-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .score-value {
            font-size: 20px;
            font-weight: bold;
            color: #4ecdc4;
        }
        .high-score .score-value {
            color: #ffe66d;
        }
        .lives .score-value {
            color: #ff6b6b;
        }
        #controls {
            margin-top: 15px;
            color: #888;
            font-size: 12px;
            text-align: center;
        }
        #controls span {
            margin: 0 15px;
        }
        #audioControls {
            margin-top: 10px;
            display: flex;
            gap: 20px;
        }
        #audioControls label {
            color: #888;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #audioControls input[type="checkbox"] {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>STAR SQUADRON</h1>
    <div id="scoreDisplay">
        <div class="score-item">
            <div class="score-label">Score</div>
            <div class="score-value" id="currentScore">0</div>
        </div>
        <div class="score-item">
            <div class="score-label">Stage</div>
            <div class="score-value" id="stageDisplay">1</div>
        </div>
        <div class="score-item lives">
            <div class="score-label">Ships</div>
            <div class="score-value" id="livesDisplay">3</div>
        </div>
        <div class="score-item high-score">
            <div class="score-label">High Score</div>
            <div class="score-value" id="highScore">0</div>
        </div>
    </div>
    <canvas id="gameCanvas" width="640" height="480"></canvas>
    <div id="controls">
        <span>Move: Arrow Keys / WASD</span>
        <span>Fire: Space / Z</span>
        <span>Pause: Escape / P</span>
    </div>
    <div id="audioControls">
        <label><input type="checkbox" id="musicToggle" checked> Music</label>
        <label><input type="checkbox" id="sfxToggle" checked> Sound Effects</label>
    </div>

    <script src="controller.js"></script>
    <script src="audio.js"></script>
    <script src="storage.js"></script>
    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            WIDTH: 640,
            HEIGHT: 480,

            // Player
            PLAYER_WIDTH: 32,
            PLAYER_HEIGHT: 24,
            PLAYER_SPEED: 5,
            PLAYER_Y: 440,
            DUAL_SHIP_OFFSET: 36,

            // Bullets
            BULLET_WIDTH: 4,
            BULLET_HEIGHT: 12,
            BULLET_SPEED: 10,
            MAX_PLAYER_BULLETS: 2,
            ENEMY_BULLET_SPEED: 5,

            // Formation
            FORMATION_COLS: 10,
            FORMATION_ROWS: 5,
            FORMATION_TOP: 60,
            FORMATION_SPACING_X: 48,
            FORMATION_SPACING_Y: 40,
            FORMATION_SWAY_AMOUNT: 20,
            FORMATION_SWAY_SPEED: 0.001,
            FORMATION_BREATHE_AMOUNT: 4,
            FORMATION_BREATHE_SPEED: 0.002,

            // Enemies
            ENEMY_WIDTH: 28,
            ENEMY_HEIGHT: 24,
            DIVE_SPEED: 0.6,
            ENTRY_SPEED: 1.0,

            // Boss (Commander)
            BOSS_WIDTH: 32,
            BOSS_HEIGHT: 28,
            TRACTOR_BEAM_WIDTH: 48,
            TRACTOR_BEAM_SPEED: 2,
            CAPTURE_DURATION: 2000,

            // Challenging Stage
            CHALLENGE_BONUS: 100,
            PERFECT_BONUS: 10000,

            // Stars
            NUM_STARS: 100,
            STAR_LAYERS: 3,

            // Timing
            SHOOT_COOLDOWN: 150,
            ENEMY_SHOOT_INTERVAL: 1500,
            DIVE_INTERVAL: 2000,
            RESPAWN_DELAY: 1500,
            STAGE_COMPLETE_DELAY: 2000,

            // Colors
            COLORS: {
                background: '#000011',
                player: '#4ecdc4',
                playerDual: '#66fff2',
                bullet: '#ffe66d',
                enemyBullet: '#ff6b6b',
                grunt: '#88dd88',
                butterfly: '#ff88ff',
                boss: '#ffdd44',
                bossDamaged: '#ff8844',
                capturedShip: '#ff6b6b',
                tractorBeam: 'rgba(136, 255, 136, 0.3)',
                explosion: '#ff6b6b',
                star: '#ffffff',
                text: '#ffffff',
                textHighlight: '#ffe66d',
                textDanger: '#ff6b6b'
            }
        };

        // ============================================
        // GAME STATE
        // ============================================
        const GameState = {
            TITLE: 'title',
            ENTERING: 'entering',      // Enemies flying into formation
            PLAYING: 'playing',
            CAPTURING: 'capturing',    // Boss capturing player
            CAPTURED: 'captured',      // Player captured, waiting
            RESCUING: 'rescuing',      // Shooting captured ship free
            DYING: 'dying',
            STAGE_COMPLETE: 'stage_complete',
            CHALLENGE_STAGE: 'challenge_stage',
            CHALLENGE_COMPLETE: 'challenge_complete',
            PAUSED: 'paused',
            GAME_OVER: 'game_over'
        };

        const EnemyType = {
            GRUNT: 0,      // Bottom rows - simple enemies
            BUTTERFLY: 1,  // Middle rows - escorts
            BOSS: 2        // Top row - can capture
        };

        const EnemyState = {
            ENTERING: 0,
            IN_FORMATION: 1,
            DIVING: 2,
            RETURNING: 3,
            CAPTURING: 4,
            ESCORTING: 5
        };

        // ============================================
        // CANVAS & CONTEXT
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ============================================
        // PERSISTENCE
        // ============================================
        const GAME_ID = 'starsquadron';
        let gameData = GameStorage.load(GAME_ID, {
            ...GameStorage.defaults.arcade(),
            highestStage: 1
        });

        function saveGameData() {
            GameStorage.save(GAME_ID, gameData);
        }

        // ============================================
        // GAME VARIABLES
        // ============================================
        let state = GameState.TITLE;
        let lastFrameTime = 0;
        let pauseTime = 0;
        const UNPAUSE_DELAY = 250;

        // Player
        let player = { x: 0, y: CONFIG.PLAYER_Y, alive: true };
        let lives = 3;
        let score = 0;
        let stage = 1;
        let isDualShip = false;
        let capturedShip = null;  // Reference to captured ship in formation
        let capturedShipX = 0;
        let capturedShipY = 0;

        // Shooting
        let playerBullets = [];
        let enemyBullets = [];
        let shootCooldown = 0;

        // Enemies
        let enemies = [];
        let formationOffsetX = 0;
        let formationOffsetY = 0;
        let formationTime = 0;

        // Entry patterns
        let entryQueue = [];
        let entryTimer = 0;
        let entriesComplete = false;

        // Diving
        let diveTimer = 0;
        let activeDivers = 0;
        const MAX_DIVERS = 2;

        // Tractor beam
        let tractorBeam = null;
        let captureTimer = 0;

        // Challenge stage
        let isChallengeStage = false;
        let challengeEnemiesTotal = 0;
        let challengeEnemiesHit = 0;

        // Effects
        let explosions = [];
        let stars = [];
        let screenShake = 0;

        // Timing
        let respawnTimer = 0;
        let stageCompleteTimer = 0;
        let isNewHighScore = false;

        // Input flags
        let startKeyPressed = false;
        let pauseKeyPressed = false;

        // ============================================
        // INITIALIZATION
        // ============================================
        function initStars() {
            stars = [];
            for (let i = 0; i < CONFIG.NUM_STARS; i++) {
                const layer = Math.floor(Math.random() * CONFIG.STAR_LAYERS);
                stars.push({
                    x: Math.random() * CONFIG.WIDTH,
                    y: Math.random() * CONFIG.HEIGHT,
                    size: 1 + layer * 0.5,
                    speed: 0.5 + layer * 0.5,
                    brightness: 0.3 + layer * 0.25
                });
            }
        }

        function initPlayer() {
            player = {
                x: CONFIG.WIDTH / 2 - CONFIG.PLAYER_WIDTH / 2,
                y: CONFIG.PLAYER_Y,
                alive: true
            };
            playerBullets = [];
        }

        function initStage() {
            enemies = [];
            enemyBullets = [];
            explosions = [];
            entryQueue = [];
            entriesComplete = false;
            entryTimer = 0;
            diveTimer = 0;
            activeDivers = 0;
            tractorBeam = null;
            captureTimer = 0;
            formationTime = 0;
            formationOffsetX = 0;
            formationOffsetY = 0;

            // Check if challenge stage (every 3rd stage after stage 3)
            isChallengeStage = stage >= 3 && (stage - 3) % 3 === 0;
            challengeEnemiesTotal = 0;
            challengeEnemiesHit = 0;

            if (isChallengeStage) {
                createChallengeStageEnemies();
            } else {
                createFormation();
            }

            state = GameState.ENTERING;
        }

        function createFormation() {
            // Create enemies in formation positions
            const startX = (CONFIG.WIDTH - (CONFIG.FORMATION_COLS - 1) * CONFIG.FORMATION_SPACING_X) / 2;

            for (let row = 0; row < CONFIG.FORMATION_ROWS; row++) {
                for (let col = 0; col < CONFIG.FORMATION_COLS; col++) {
                    // Determine enemy type based on row
                    let type;
                    if (row === 0) {
                        type = EnemyType.BOSS;
                    } else if (row <= 2) {
                        type = EnemyType.BUTTERFLY;
                    } else {
                        type = EnemyType.GRUNT;
                    }

                    // Skip some positions for bosses (they're bigger, fewer of them)
                    if (type === EnemyType.BOSS && col % 2 !== 0) continue;

                    const formationX = startX + col * CONFIG.FORMATION_SPACING_X;
                    const formationY = CONFIG.FORMATION_TOP + row * CONFIG.FORMATION_SPACING_Y;

                    const enemy = {
                        type,
                        formationCol: col,
                        formationRow: row,
                        formationX,
                        formationY,
                        x: 0,
                        y: 0,
                        state: EnemyState.ENTERING,
                        health: type === EnemyType.BOSS ? 2 : 1,
                        entryPath: null,
                        entryT: 0,
                        divePath: null,
                        diveT: 0,
                        hasCapturedShip: false,
                        escorts: []
                    };

                    enemies.push(enemy);
                }
            }

            // Create entry patterns
            createEntryPatterns();
        }

        function createEntryPatterns() {
            // Galaga-style entry: enemies fly in snake formation, then peel off to positions
            const groups = [];

            // Group enemies by type for wave-style entry
            const bosses = enemies.filter(e => e.type === EnemyType.BOSS);
            const butterflies = enemies.filter(e => e.type === EnemyType.BUTTERFLY);
            const grunts = enemies.filter(e => e.type === EnemyType.GRUNT);

            // Wave 1: First row of grunts from right
            groups.push({ enemies: grunts.slice(0, 5), side: 'right', delay: 0 });
            // Wave 2: Second row of grunts from left
            groups.push({ enemies: grunts.slice(5, 10), side: 'left', delay: 2000 });
            // Wave 3: First row of butterflies from right
            groups.push({ enemies: butterflies.slice(0, 5), side: 'right', delay: 4000 });
            // Wave 4: Second row of butterflies from left
            groups.push({ enemies: butterflies.slice(5, 10), side: 'left', delay: 6000 });
            // Wave 5: Bosses from top center
            groups.push({ enemies: bosses, side: 'top', delay: 8000 });

            // Create shared path for each group - all enemies follow same path as snake
            groups.forEach(group => {
                const sharedPath = createGroupEntryPath(group.side);

                group.enemies.forEach((enemy, idx) => {
                    // All enemies start at same time but with offset along the path
                    enemy.entryDelay = group.delay;
                    enemy.entryPath = sharedPath;
                    enemy.entryOffset = idx * 0.08; // Spacing along the snake
                    enemy.peelOffT = 0.75; // When to start peeling off to formation
                    enemy.entryT = -enemy.entryOffset; // Start behind in the snake
                    entryQueue.push({ enemy, delay: group.delay });
                });
            });

            entryQueue.sort((a, b) => a.delay - b.delay);
        }

        function createGroupEntryPath(side) {
            // Create a shared path that all enemies in the group follow as a snake
            let points;

            if (side === 'right') {
                // Swoop in from top-right, loop down and around
                points = [
                    { x: CONFIG.WIDTH + 50, y: -50 },
                    { x: CONFIG.WIDTH * 0.8, y: CONFIG.HEIGHT * 0.1 },
                    { x: CONFIG.WIDTH * 0.6, y: CONFIG.HEIGHT * 0.3 },
                    { x: CONFIG.WIDTH * 0.3, y: CONFIG.HEIGHT * 0.5 },
                    { x: CONFIG.WIDTH * 0.2, y: CONFIG.HEIGHT * 0.6 },
                    { x: CONFIG.WIDTH * 0.3, y: CONFIG.HEIGHT * 0.5 },
                    { x: CONFIG.WIDTH * 0.5, y: CONFIG.HEIGHT * 0.3 },
                    { x: CONFIG.WIDTH * 0.5, y: CONFIG.HEIGHT * 0.15 }  // End near formation area
                ];
            } else if (side === 'left') {
                // Mirror from left side
                points = [
                    { x: -50, y: -50 },
                    { x: CONFIG.WIDTH * 0.2, y: CONFIG.HEIGHT * 0.1 },
                    { x: CONFIG.WIDTH * 0.4, y: CONFIG.HEIGHT * 0.3 },
                    { x: CONFIG.WIDTH * 0.7, y: CONFIG.HEIGHT * 0.5 },
                    { x: CONFIG.WIDTH * 0.8, y: CONFIG.HEIGHT * 0.6 },
                    { x: CONFIG.WIDTH * 0.7, y: CONFIG.HEIGHT * 0.5 },
                    { x: CONFIG.WIDTH * 0.5, y: CONFIG.HEIGHT * 0.3 },
                    { x: CONFIG.WIDTH * 0.5, y: CONFIG.HEIGHT * 0.15 }
                ];
            } else {
                // Top entry for bosses - dramatic diving loop
                points = [
                    { x: CONFIG.WIDTH * 0.5, y: -50 },
                    { x: CONFIG.WIDTH * 0.7, y: CONFIG.HEIGHT * 0.15 },
                    { x: CONFIG.WIDTH * 0.8, y: CONFIG.HEIGHT * 0.4 },
                    { x: CONFIG.WIDTH * 0.6, y: CONFIG.HEIGHT * 0.6 },
                    { x: CONFIG.WIDTH * 0.4, y: CONFIG.HEIGHT * 0.6 },
                    { x: CONFIG.WIDTH * 0.2, y: CONFIG.HEIGHT * 0.4 },
                    { x: CONFIG.WIDTH * 0.3, y: CONFIG.HEIGHT * 0.15 },
                    { x: CONFIG.WIDTH * 0.5, y: CONFIG.HEIGHT * 0.1 }
                ];
            }

            return points;
        }

        function createChallengeStageEnemies() {
            // Challenge stage: waves of enemies fly across screen
            // They don't shoot, just fly in patterns for bonus points
            challengeEnemiesTotal = 40;

            for (let wave = 0; wave < 4; wave++) {
                for (let i = 0; i < 10; i++) {
                    const enemy = {
                        type: wave < 2 ? EnemyType.BUTTERFLY : EnemyType.GRUNT,
                        x: -50,
                        y: -50,
                        state: EnemyState.ENTERING,
                        health: 1,
                        entryPath: createChallengePath(wave, i),
                        entryT: 0,
                        entryDelay: wave * 1500 + i * 100,
                        isChallenge: true
                    };
                    enemies.push(enemy);
                    entryQueue.push({ enemy, delay: enemy.entryDelay });
                }
            }

            entryQueue.sort((a, b) => a.delay - b.delay);
        }

        function createChallengePath(wave, index) {
            const patterns = [
                // Wave 1: Figure 8 from left
                () => {
                    const startX = -50;
                    const startY = 150;
                    return [
                        { x: startX, y: startY },
                        { x: CONFIG.WIDTH * 0.25, y: 100 },
                        { x: CONFIG.WIDTH * 0.5, y: 250 },
                        { x: CONFIG.WIDTH * 0.75, y: 100 },
                        { x: CONFIG.WIDTH + 50, y: 150 }
                    ];
                },
                // Wave 2: Dive bomb from top
                () => {
                    const startX = 100 + index * 50;
                    return [
                        { x: startX, y: -50 },
                        { x: startX + 50, y: CONFIG.HEIGHT * 0.3 },
                        { x: startX, y: CONFIG.HEIGHT * 0.6 },
                        { x: startX - 100, y: CONFIG.HEIGHT + 50 }
                    ];
                },
                // Wave 3: Spiral from right
                () => {
                    const startX = CONFIG.WIDTH + 50;
                    const startY = 200;
                    return [
                        { x: startX, y: startY },
                        { x: CONFIG.WIDTH * 0.6, y: 350 },
                        { x: CONFIG.WIDTH * 0.3, y: 200 },
                        { x: CONFIG.WIDTH * 0.5, y: 100 },
                        { x: -50, y: 200 }
                    ];
                },
                // Wave 4: V formation from top
                () => {
                    const centerX = CONFIG.WIDTH / 2;
                    const offsetX = (index - 4.5) * 30;
                    return [
                        { x: centerX + offsetX, y: -50 },
                        { x: centerX + offsetX * 1.5, y: CONFIG.HEIGHT * 0.3 },
                        { x: centerX + offsetX * 0.5, y: CONFIG.HEIGHT * 0.5 },
                        { x: centerX + offsetX, y: CONFIG.HEIGHT + 50 }
                    ];
                }
            ];

            return patterns[wave]();
        }

        function initGame() {
            lives = 3;
            score = 0;
            stage = 1;
            isDualShip = false;
            capturedShip = null;
            isNewHighScore = false;

            initPlayer();
            initStars();
            initStage();

            updateDisplays();
        }

        // ============================================
        // BEZIER CURVE HELPERS
        // ============================================
        function bezierPoint(points, t) {
            // De Casteljau's algorithm for arbitrary number of control points
            if (points.length === 1) return points[0];

            const newPoints = [];
            for (let i = 0; i < points.length - 1; i++) {
                newPoints.push({
                    x: points[i].x + (points[i + 1].x - points[i].x) * t,
                    y: points[i].y + (points[i + 1].y - points[i].y) * t
                });
            }
            return bezierPoint(newPoints, t);
        }

        // ============================================
        // UPDATE FUNCTIONS
        // ============================================
        function updateStars(deltaTime) {
            for (const star of stars) {
                star.y += star.speed * deltaTime * 0.05;
                if (star.y > CONFIG.HEIGHT) {
                    star.y = 0;
                    star.x = Math.random() * CONFIG.WIDTH;
                }
            }
        }

        function updatePlayer(deltaTime) {
            if (!player.alive) return;

            // Movement
            if (GameController.direction.left) {
                player.x -= CONFIG.PLAYER_SPEED;
            }
            if (GameController.direction.right) {
                player.x += CONFIG.PLAYER_SPEED;
            }

            // Clamp to screen
            const maxX = isDualShip ?
                CONFIG.WIDTH - CONFIG.PLAYER_WIDTH - CONFIG.DUAL_SHIP_OFFSET :
                CONFIG.WIDTH - CONFIG.PLAYER_WIDTH;
            player.x = Math.max(0, Math.min(maxX, player.x));

            // Shooting
            if (shootCooldown > 0) {
                shootCooldown -= deltaTime;
            }

            if (GameController.justPressed('a') && shootCooldown <= 0) {
                shoot();
            }
        }

        function shoot() {
            if (playerBullets.length >= CONFIG.MAX_PLAYER_BULLETS) return;

            // Primary shot
            playerBullets.push({
                x: player.x + CONFIG.PLAYER_WIDTH / 2 - CONFIG.BULLET_WIDTH / 2,
                y: player.y - CONFIG.BULLET_HEIGHT
            });

            // Dual ship fires second bullet
            if (isDualShip) {
                playerBullets.push({
                    x: player.x + CONFIG.DUAL_SHIP_OFFSET + CONFIG.PLAYER_WIDTH / 2 - CONFIG.BULLET_WIDTH / 2,
                    y: player.y - CONFIG.BULLET_HEIGHT
                });
            }

            shootCooldown = CONFIG.SHOOT_COOLDOWN;
            AudioSystem.sfx.shoot();
        }

        function updateBullets(deltaTime) {
            // Player bullets
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                playerBullets[i].y -= CONFIG.BULLET_SPEED;
                if (playerBullets[i].y < -CONFIG.BULLET_HEIGHT) {
                    playerBullets.splice(i, 1);
                }
            }

            // Enemy bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                enemyBullets[i].y += CONFIG.ENEMY_BULLET_SPEED;
                if (enemyBullets[i].y > CONFIG.HEIGHT) {
                    enemyBullets.splice(i, 1);
                }
            }
        }

        function updateFormation(deltaTime) {
            formationTime += deltaTime;

            // Sway side to side
            formationOffsetX = Math.sin(formationTime * CONFIG.FORMATION_SWAY_SPEED) * CONFIG.FORMATION_SWAY_AMOUNT;

            // Breathe (expand/contract)
            formationOffsetY = Math.sin(formationTime * CONFIG.FORMATION_BREATHE_SPEED) * CONFIG.FORMATION_BREATHE_AMOUNT;
        }

        function updateEnemyEntry(deltaTime) {
            entryTimer += deltaTime;

            // Start new entries - mark groups as active when their delay is reached
            while (entryQueue.length > 0 && entryQueue[0].delay <= entryTimer) {
                entryQueue.shift();
            }

            // Update entering enemies
            let allInFormation = true;
            for (const enemy of enemies) {
                if (enemy.state === EnemyState.ENTERING && enemy.entryPath) {
                    if (enemy.entryDelay <= entryTimer) {
                        // Advance along the path
                        enemy.entryT += deltaTime * 0.001 * CONFIG.ENTRY_SPEED;

                        // Calculate effective t (clamped to 0-1 for path lookup)
                        const effectiveT = Math.max(0, Math.min(1, enemy.entryT));

                        if (enemy.entryT >= 1) {
                            // Reached end of entry - now in formation
                            if (!enemy.isChallenge) {
                                enemy.state = EnemyState.IN_FORMATION;
                                enemy.x = enemy.formationX;
                                enemy.y = enemy.formationY;
                            }
                        } else if (enemy.entryT < 0) {
                            // Still waiting to appear (behind in snake)
                            enemy.x = -100;
                            enemy.y = -100;
                            allInFormation = false;
                        } else if (effectiveT >= enemy.peelOffT) {
                            // Peeling off from snake to formation position
                            const peelProgress = (effectiveT - enemy.peelOffT) / (1 - enemy.peelOffT);
                            const pathPos = bezierPoint(enemy.entryPath, enemy.peelOffT);

                            // Lerp from path position to formation position
                            enemy.x = pathPos.x + (enemy.formationX - pathPos.x) * peelProgress;
                            enemy.y = pathPos.y + (enemy.formationY - pathPos.y) * peelProgress;
                            allInFormation = false;
                        } else {
                            // Following the snake path
                            const pos = bezierPoint(enemy.entryPath, effectiveT);
                            enemy.x = pos.x;
                            enemy.y = pos.y;
                            allInFormation = false;
                        }
                    } else {
                        allInFormation = false;
                    }
                }
            }

            // Remove challenge enemies that finished their path
            if (isChallengeStage) {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (enemy.isChallenge && enemy.entryT >= 1) {
                        enemies.splice(i, 1);
                    }
                }
            }

            if (allInFormation && entryQueue.length === 0) {
                entriesComplete = true;
                if (isChallengeStage) {
                    state = GameState.CHALLENGE_COMPLETE;
                    stageCompleteTimer = CONFIG.STAGE_COMPLETE_DELAY;
                } else {
                    state = GameState.PLAYING;
                }
            }
        }

        function updateEnemies(deltaTime) {
            updateFormation(deltaTime);

            // Update enemy positions based on state
            for (const enemy of enemies) {
                switch (enemy.state) {
                    case EnemyState.IN_FORMATION:
                        // Follow formation with sway/breathe
                        enemy.x = enemy.formationX + formationOffsetX;
                        enemy.y = enemy.formationY + formationOffsetY * (enemy.formationRow * 0.2);
                        break;

                    case EnemyState.DIVING:
                        updateDivingEnemy(enemy, deltaTime);
                        break;

                    case EnemyState.RETURNING:
                        updateReturningEnemy(enemy, deltaTime);
                        break;

                    case EnemyState.CAPTURING:
                        updateCapturingEnemy(enemy, deltaTime);
                        break;
                }
            }

            // Update captured ship position (follows its captor)
            if (capturedShip && capturedShip.hasCapturedShip) {
                capturedShipX = capturedShip.x;
                capturedShipY = capturedShip.y + CONFIG.BOSS_HEIGHT + 5;
            }

            // Initiate dives
            if (!isChallengeStage && entriesComplete && activeDivers < MAX_DIVERS) {
                diveTimer += deltaTime;
                const diveInterval = CONFIG.DIVE_INTERVAL - stage * 50;

                if (diveTimer >= diveInterval) {
                    diveTimer = 0;
                    initiateDive();
                }
            }

            // Enemy shooting
            if (!isChallengeStage && entriesComplete && Math.random() < deltaTime / CONFIG.ENEMY_SHOOT_INTERVAL) {
                enemyShoot();
            }
        }

        function initiateDive() {
            // Pick a random enemy in formation to dive
            const inFormation = enemies.filter(e => e.state === EnemyState.IN_FORMATION);
            if (inFormation.length === 0) return;

            const diver = inFormation[Math.floor(Math.random() * inFormation.length)];

            // Bosses with captured ships bring the captured ship too
            if (diver.type === EnemyType.BOSS && Math.random() < 0.3 && !diver.hasCapturedShip) {
                // Boss might try to capture
                if (!capturedShip && lives > 1) {
                    startCapture(diver);
                    return;
                }
            }

            startDive(diver);
        }

        function startDive(enemy) {
            enemy.state = EnemyState.DIVING;
            activeDivers++;

            // Create dive path - sweeping attack with loops like real Galaga
            const targetX = player.x + CONFIG.PLAYER_WIDTH / 2;
            const startX = enemy.x;
            const startY = enemy.y;

            // Determine attack pattern based on enemy position
            const fromLeft = startX < CONFIG.WIDTH / 2;
            const loopDir = fromLeft ? 1 : -1;

            // Galaga-style: loop down, sweep across, then exit bottom
            enemy.divePath = [
                { x: startX, y: startY },
                // First curve down
                { x: startX + loopDir * 60, y: startY + 80 },
                // Loop around
                { x: startX + loopDir * 120, y: CONFIG.HEIGHT * 0.4 },
                { x: startX + loopDir * 80, y: CONFIG.HEIGHT * 0.55 },
                // Sweep toward player
                { x: targetX + loopDir * 50, y: CONFIG.HEIGHT * 0.65 },
                // Exit at bottom
                { x: targetX, y: CONFIG.HEIGHT + 50 }
            ];
            enemy.diveT = 0;

            // If boss has captured ship, escorts might join
            if (enemy.hasCapturedShip) {
                // Find nearby butterflies to escort
                const escorts = enemies.filter(e =>
                    e.state === EnemyState.IN_FORMATION &&
                    e.type === EnemyType.BUTTERFLY &&
                    Math.abs(e.formationCol - enemy.formationCol) <= 2
                ).slice(0, 2);

                escorts.forEach((escort, idx) => {
                    escort.state = EnemyState.ESCORTING;
                    escort.escortTarget = enemy;
                    escort.escortOffset = { x: (idx === 0 ? -40 : 40), y: 20 };
                    activeDivers++;
                });
            }
        }

        function startCapture(boss) {
            boss.state = EnemyState.CAPTURING;
            activeDivers++;

            // Fly down to capture position
            boss.divePath = [
                { x: boss.x, y: boss.y },
                { x: player.x + CONFIG.PLAYER_WIDTH / 2, y: CONFIG.HEIGHT * 0.4 }
            ];
            boss.diveT = 0;

            state = GameState.CAPTURING;
            captureTimer = 0;
        }

        function updateDivingEnemy(enemy, deltaTime) {
            enemy.diveT += deltaTime * 0.002 * CONFIG.DIVE_SPEED;

            if (enemy.diveT >= 1) {
                // Dive complete - loop back to formation
                enemy.state = EnemyState.RETURNING;
                enemy.diveT = 0;
                activeDivers--;

                // Create return path
                enemy.divePath = [
                    { x: enemy.x < CONFIG.WIDTH / 2 ? -30 : CONFIG.WIDTH + 30, y: -30 },
                    { x: enemy.formationX, y: enemy.formationY }
                ];
            } else {
                const pos = bezierPoint(enemy.divePath, enemy.diveT);
                enemy.x = pos.x;
                enemy.y = pos.y;

                // Shoot while diving
                if (Math.random() < 0.02) {
                    enemyBullets.push({
                        x: enemy.x + CONFIG.ENEMY_WIDTH / 2,
                        y: enemy.y + CONFIG.ENEMY_HEIGHT
                    });
                }
            }

            // Update escorts
            if (enemy.type === EnemyType.BOSS) {
                const escorts = enemies.filter(e => e.escortTarget === enemy);
                escorts.forEach(escort => {
                    escort.x = enemy.x + escort.escortOffset.x;
                    escort.y = enemy.y + escort.escortOffset.y;
                });
            }
        }

        function updateReturningEnemy(enemy, deltaTime) {
            enemy.diveT += deltaTime * 0.003;

            if (enemy.diveT >= 1) {
                enemy.state = EnemyState.IN_FORMATION;
                enemy.x = enemy.formationX;
                enemy.y = enemy.formationY;
            } else {
                const pos = bezierPoint(enemy.divePath, enemy.diveT);
                enemy.x = pos.x;
                enemy.y = pos.y;
            }
        }

        function updateCapturingEnemy(boss, deltaTime) {
            if (boss.diveT < 1) {
                boss.diveT += deltaTime * 0.002;
                const pos = bezierPoint(boss.divePath, Math.min(boss.diveT, 1));
                boss.x = pos.x - CONFIG.BOSS_WIDTH / 2;
                boss.y = pos.y;
            } else {
                // In capture position - activate tractor beam
                if (!tractorBeam) {
                    tractorBeam = {
                        x: boss.x + CONFIG.BOSS_WIDTH / 2 - CONFIG.TRACTOR_BEAM_WIDTH / 2,
                        y: boss.y + CONFIG.BOSS_HEIGHT,
                        width: CONFIG.TRACTOR_BEAM_WIDTH,
                        height: 0,
                        maxHeight: CONFIG.PLAYER_Y - boss.y - CONFIG.BOSS_HEIGHT
                    };
                }

                // Extend beam
                if (tractorBeam.height < tractorBeam.maxHeight) {
                    tractorBeam.height += CONFIG.TRACTOR_BEAM_SPEED * deltaTime * 0.1;
                }

                captureTimer += deltaTime;

                // Check if player is caught
                if (player.alive && tractorBeam.height >= tractorBeam.maxHeight * 0.9) {
                    const beamCenterX = tractorBeam.x + tractorBeam.width / 2;
                    const playerCenterX = player.x + CONFIG.PLAYER_WIDTH / 2;

                    if (Math.abs(beamCenterX - playerCenterX) < CONFIG.TRACTOR_BEAM_WIDTH / 2 + CONFIG.PLAYER_WIDTH / 2) {
                        // Captured!
                        capturePlayer(boss);
                    }
                }

                // Timeout - return to formation
                if (captureTimer >= CONFIG.CAPTURE_DURATION) {
                    tractorBeam = null;
                    boss.state = EnemyState.RETURNING;
                    boss.diveT = 0;
                    boss.divePath = [
                        { x: boss.x, y: boss.y },
                        { x: boss.formationX, y: boss.formationY }
                    ];
                    activeDivers--;
                    state = GameState.PLAYING;
                }
            }
        }

        function capturePlayer(boss) {
            player.alive = false;
            boss.hasCapturedShip = true;
            capturedShip = boss;
            capturedShipX = player.x;
            capturedShipY = player.y;

            tractorBeam = null;
            state = GameState.CAPTURED;

            AudioSystem.sfx.death();

            lives--;
            updateDisplays();

            if (lives <= 0) {
                gameOver();
            } else {
                // Boss returns to formation with captured ship
                boss.state = EnemyState.RETURNING;
                boss.diveT = 0;
                boss.divePath = [
                    { x: boss.x, y: boss.y },
                    { x: boss.formationX, y: boss.formationY }
                ];
                activeDivers--;

                respawnTimer = CONFIG.RESPAWN_DELAY;
            }
        }

        function rescueCapturedShip(boss) {
            // Player shot the boss that had their ship!
            isDualShip = true;
            boss.hasCapturedShip = false;
            capturedShip = null;

            AudioSystem.sfx.powerUp();

            // Animate captured ship flying down to join player
            // For now, instant join
        }

        function enemyShoot() {
            const shooters = enemies.filter(e =>
                (e.state === EnemyState.IN_FORMATION || e.state === EnemyState.DIVING) &&
                e.y < CONFIG.HEIGHT - 100
            );

            if (shooters.length === 0) return;

            const shooter = shooters[Math.floor(Math.random() * shooters.length)];
            enemyBullets.push({
                x: shooter.x + CONFIG.ENEMY_WIDTH / 2,
                y: shooter.y + CONFIG.ENEMY_HEIGHT
            });
        }

        function updateCollisions() {
            // Player bullets vs enemies
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet = playerBullets[i];

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const width = enemy.type === EnemyType.BOSS ? CONFIG.BOSS_WIDTH : CONFIG.ENEMY_WIDTH;
                    const height = enemy.type === EnemyType.BOSS ? CONFIG.BOSS_HEIGHT : CONFIG.ENEMY_HEIGHT;

                    if (bullet.x < enemy.x + width &&
                        bullet.x + CONFIG.BULLET_WIDTH > enemy.x &&
                        bullet.y < enemy.y + height &&
                        bullet.y + CONFIG.BULLET_HEIGHT > enemy.y) {

                        playerBullets.splice(i, 1);

                        enemy.health--;

                        if (enemy.health <= 0) {
                            // Check if this boss had captured ship
                            if (enemy === capturedShip) {
                                rescueCapturedShip(enemy);
                            }

                            // Score based on type and state
                            let points = 50;
                            if (enemy.type === EnemyType.BUTTERFLY) points = 80;
                            if (enemy.type === EnemyType.BOSS) points = enemy.state === EnemyState.DIVING ? 400 : 150;
                            if (isChallengeStage) {
                                points = CONFIG.CHALLENGE_BONUS;
                                challengeEnemiesHit++;
                            }

                            score += points;

                            // Explosion
                            addExplosion(enemy.x + width / 2, enemy.y + height / 2, width);
                            AudioSystem.sfx.explosion();

                            // Handle escorts if boss died
                            if (enemy.type === EnemyType.BOSS) {
                                const escorts = enemies.filter(e => e.escortTarget === enemy);
                                escorts.forEach(e => {
                                    e.escortTarget = null;
                                    e.state = EnemyState.RETURNING;
                                    e.diveT = 0;
                                    e.divePath = [
                                        { x: e.x, y: e.y },
                                        { x: e.formationX, y: e.formationY }
                                    ];
                                });
                            }

                            if (enemy.state === EnemyState.DIVING || enemy.state === EnemyState.ESCORTING) {
                                activeDivers--;
                            }

                            enemies.splice(j, 1);
                        } else {
                            // Boss hit but not dead
                            AudioSystem.sfx.hit();
                        }

                        updateDisplays();
                        break;
                    }
                }

                // Check if bullet hit captured ship (to rescue it)
                if (capturedShip && capturedShip.hasCapturedShip && playerBullets[i]) {
                    const bullet = playerBullets[i];
                    if (bullet.x < capturedShipX + CONFIG.PLAYER_WIDTH &&
                        bullet.x + CONFIG.BULLET_WIDTH > capturedShipX &&
                        bullet.y < capturedShipY + CONFIG.PLAYER_HEIGHT &&
                        bullet.y + CONFIG.BULLET_HEIGHT > capturedShipY) {

                        // Shot our own captured ship - it's destroyed, no rescue
                        playerBullets.splice(i, 1);
                        capturedShip.hasCapturedShip = false;
                        addExplosion(capturedShipX + CONFIG.PLAYER_WIDTH / 2, capturedShipY + CONFIG.PLAYER_HEIGHT / 2, CONFIG.PLAYER_WIDTH);
                        capturedShip = null;
                        AudioSystem.sfx.death();
                    }
                }
            }

            // Enemy bullets vs player
            if (player.alive) {
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = enemyBullets[i];

                    // Check main ship
                    if (bullet.x < player.x + CONFIG.PLAYER_WIDTH &&
                        bullet.x + CONFIG.BULLET_WIDTH > player.x &&
                        bullet.y < player.y + CONFIG.PLAYER_HEIGHT &&
                        bullet.y + CONFIG.BULLET_HEIGHT > player.y) {

                        enemyBullets.splice(i, 1);
                        killPlayer();
                        break;
                    }

                    // Check dual ship
                    if (isDualShip) {
                        const dualX = player.x + CONFIG.DUAL_SHIP_OFFSET;
                        if (bullet.x < dualX + CONFIG.PLAYER_WIDTH &&
                            bullet.x + CONFIG.BULLET_WIDTH > dualX &&
                            bullet.y < player.y + CONFIG.PLAYER_HEIGHT &&
                            bullet.y + CONFIG.BULLET_HEIGHT > player.y) {

                            enemyBullets.splice(i, 1);
                            // Lose dual ship, not a life
                            isDualShip = false;
                            addExplosion(dualX + CONFIG.PLAYER_WIDTH / 2, player.y + CONFIG.PLAYER_HEIGHT / 2, CONFIG.PLAYER_WIDTH);
                            AudioSystem.sfx.hit();
                            break;
                        }
                    }
                }
            }

            // Diving enemies vs player
            if (player.alive) {
                for (const enemy of enemies) {
                    if (enemy.state !== EnemyState.DIVING && enemy.state !== EnemyState.ESCORTING) continue;

                    const width = enemy.type === EnemyType.BOSS ? CONFIG.BOSS_WIDTH : CONFIG.ENEMY_WIDTH;
                    const height = enemy.type === EnemyType.BOSS ? CONFIG.BOSS_HEIGHT : CONFIG.ENEMY_HEIGHT;

                    if (enemy.x < player.x + CONFIG.PLAYER_WIDTH &&
                        enemy.x + width > player.x &&
                        enemy.y < player.y + CONFIG.PLAYER_HEIGHT &&
                        enemy.y + height > player.y) {

                        killPlayer();
                        break;
                    }
                }
            }
        }

        function killPlayer() {
            player.alive = false;
            addExplosion(player.x + CONFIG.PLAYER_WIDTH / 2, player.y + CONFIG.PLAYER_HEIGHT / 2, CONFIG.PLAYER_WIDTH);
            AudioSystem.sfx.death();
            screenShake = 10;

            lives--;
            if (isDualShip) {
                isDualShip = false;
            }

            updateDisplays();

            if (lives <= 0) {
                gameOver();
            } else {
                state = GameState.DYING;
                respawnTimer = CONFIG.RESPAWN_DELAY;
            }
        }

        function respawnPlayer() {
            player.alive = true;
            player.x = CONFIG.WIDTH / 2 - CONFIG.PLAYER_WIDTH / 2;
            playerBullets = [];
            shootCooldown = 0;
            state = GameState.PLAYING;
        }

        function checkStageComplete() {
            if (enemies.length === 0 && entriesComplete) {
                state = GameState.STAGE_COMPLETE;
                stageCompleteTimer = CONFIG.STAGE_COMPLETE_DELAY;
                AudioSystem.sfx.levelComplete();
            }
        }

        function nextStage() {
            stage++;
            if (stage > gameData.highestStage) {
                gameData.highestStage = stage;
                saveGameData();
            }
            updateDisplays();
            initStage();
        }

        function addExplosion(x, y, size) {
            const particles = [];
            const numParticles = 12 + Math.floor(size / 4);

            for (let i = 0; i < numParticles; i++) {
                const angle = (Math.PI * 2 * i) / numParticles + Math.random() * 0.5;
                const speed = 1 + Math.random() * 3;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3,
                    life: 1
                });
            }

            explosions.push({
                x, y, size,
                particles,
                timer: 500
            });
        }

        function updateExplosions(deltaTime) {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.timer -= deltaTime;

                for (const p of exp.particles) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.05; // gravity
                    p.life -= deltaTime / 500;
                }

                if (exp.timer <= 0) {
                    explosions.splice(i, 1);
                }
            }

            // Screen shake decay
            if (screenShake > 0) {
                screenShake *= 0.9;
                if (screenShake < 0.5) screenShake = 0;
            }
        }

        function gameOver() {
            state = GameState.GAME_OVER;
            AudioSystem.music.stop();
            AudioSystem.sfx.gameOver();

            if (score > gameData.highScore) {
                gameData.highScore = score;
                isNewHighScore = gameData.gamesPlayed > 0;
            }
            gameData.gamesPlayed++;
            saveGameData();
            updateDisplays();
        }

        // ============================================
        // MAIN UPDATE BY STATE
        // ============================================
        function updateTitle() {
            updateStars(16);

            if (GameController.anyButtonJustPressed() || startKeyPressed) {
                startKeyPressed = false;
                AudioSystem.unlock();
                initGame();
                AudioSystem.music.start('invaders');
            }
        }

        function updateEntering(deltaTime) {
            updateStars(deltaTime);
            updatePlayer(deltaTime);
            updateBullets(deltaTime);
            updateEnemyEntry(deltaTime);
            updateExplosions(deltaTime);
            updateCollisions();

            // Handle pause
            if (GameController.justPressed('start') || pauseKeyPressed) {
                pauseKeyPressed = false;
                pause();
            }
        }

        function updatePlaying(deltaTime) {
            updateStars(deltaTime);
            updatePlayer(deltaTime);
            updateBullets(deltaTime);
            updateEnemies(deltaTime);
            updateExplosions(deltaTime);
            updateCollisions();
            checkStageComplete();

            // Handle pause
            if (GameController.justPressed('start') || pauseKeyPressed) {
                pauseKeyPressed = false;
                pause();
            }
        }

        function updateCapturing(deltaTime) {
            updateStars(deltaTime);
            updatePlayer(deltaTime);
            updateBullets(deltaTime);
            updateEnemies(deltaTime);
            updateExplosions(deltaTime);
            updateCollisions();

            // Can still pause during capture
            if (GameController.justPressed('start') || pauseKeyPressed) {
                pauseKeyPressed = false;
                pause();
            }
        }

        function updateCaptured(deltaTime) {
            updateStars(deltaTime);
            updateEnemies(deltaTime);
            updateExplosions(deltaTime);

            respawnTimer -= deltaTime;
            if (respawnTimer <= 0) {
                respawnPlayer();
            }
        }

        function updateDying(deltaTime) {
            updateStars(deltaTime);
            updateBullets(deltaTime);
            updateEnemies(deltaTime);
            updateExplosions(deltaTime);

            respawnTimer -= deltaTime;
            if (respawnTimer <= 0) {
                respawnPlayer();
            }
        }

        function updateStageComplete(deltaTime) {
            updateStars(deltaTime);
            updateExplosions(deltaTime);

            stageCompleteTimer -= deltaTime;
            if (stageCompleteTimer <= 0) {
                nextStage();
            }
        }

        function updateChallengeComplete(deltaTime) {
            updateStars(deltaTime);
            updateExplosions(deltaTime);

            stageCompleteTimer -= deltaTime;
            if (stageCompleteTimer <= 0) {
                // Award perfect bonus
                if (challengeEnemiesHit === challengeEnemiesTotal) {
                    score += CONFIG.PERFECT_BONUS;
                    updateDisplays();
                }
                nextStage();
            }
        }

        function updatePaused(deltaTime) {
            pauseTime += deltaTime;

            if (pauseTime >= UNPAUSE_DELAY && (GameController.justPressed('start') || pauseKeyPressed)) {
                pauseKeyPressed = false;
                unpause();
            }
        }

        function updateGameOver() {
            updateStars(16);

            if (GameController.anyButtonJustPressed() || startKeyPressed) {
                startKeyPressed = false;
                state = GameState.TITLE;
            }
        }

        function pause() {
            state = GameState.PAUSED;
            pauseTime = 0;
            AudioSystem.music.stop();
        }

        function unpause() {
            state = GameState.PLAYING;
            AudioSystem.music.start('invaders');
        }

        // ============================================
        // RENDER FUNCTIONS
        // ============================================
        function renderBackground() {
            ctx.fillStyle = CONFIG.COLORS.background;
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        }

        function renderStars() {
            for (const star of stars) {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
                ctx.fillRect(star.x, star.y, star.size, star.size);
            }
        }

        function renderPlayer() {
            if (!player.alive) return;

            // Apply screen shake
            const shakeX = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;
            const shakeY = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;

            ctx.save();
            ctx.translate(shakeX, shakeY);

            // Main ship
            drawShip(player.x, player.y, CONFIG.COLORS.player);

            // Dual ship
            if (isDualShip) {
                drawShip(player.x + CONFIG.DUAL_SHIP_OFFSET, player.y, CONFIG.COLORS.playerDual);
            }

            ctx.restore();
        }

        function drawShip(x, y, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            // Ship body
            ctx.moveTo(x + CONFIG.PLAYER_WIDTH / 2, y);
            ctx.lineTo(x + CONFIG.PLAYER_WIDTH, y + CONFIG.PLAYER_HEIGHT);
            ctx.lineTo(x + CONFIG.PLAYER_WIDTH * 0.7, y + CONFIG.PLAYER_HEIGHT * 0.7);
            ctx.lineTo(x + CONFIG.PLAYER_WIDTH * 0.3, y + CONFIG.PLAYER_HEIGHT * 0.7);
            ctx.lineTo(x, y + CONFIG.PLAYER_HEIGHT);
            ctx.closePath();
            ctx.fill();

            // Cockpit
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x + CONFIG.PLAYER_WIDTH / 2, y + CONFIG.PLAYER_HEIGHT * 0.4, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function renderBullets() {
            // Player bullets
            ctx.fillStyle = CONFIG.COLORS.bullet;
            for (const bullet of playerBullets) {
                ctx.fillRect(bullet.x, bullet.y, CONFIG.BULLET_WIDTH, CONFIG.BULLET_HEIGHT);
            }

            // Enemy bullets
            ctx.fillStyle = CONFIG.COLORS.enemyBullet;
            for (const bullet of enemyBullets) {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function renderEnemies() {
            for (const enemy of enemies) {
                if (enemy.state === EnemyState.ENTERING && enemy.entryDelay > entryTimer) {
                    continue; // Not yet entered
                }

                switch (enemy.type) {
                    case EnemyType.GRUNT:
                        drawGrunt(enemy.x, enemy.y);
                        break;
                    case EnemyType.BUTTERFLY:
                        drawButterfly(enemy.x, enemy.y);
                        break;
                    case EnemyType.BOSS:
                        drawBoss(enemy.x, enemy.y, enemy.health, enemy.hasCapturedShip);
                        break;
                }
            }

            // Draw captured ship if exists
            if (capturedShip && capturedShip.hasCapturedShip) {
                drawCapturedShip(capturedShipX, capturedShipY);
            }
        }

        function drawGrunt(x, y) {
            ctx.fillStyle = CONFIG.COLORS.grunt;
            // Simple bee-like shape
            ctx.beginPath();
            ctx.ellipse(x + CONFIG.ENEMY_WIDTH / 2, y + CONFIG.ENEMY_HEIGHT / 2,
                       CONFIG.ENEMY_WIDTH / 2, CONFIG.ENEMY_HEIGHT / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wings
            ctx.fillStyle = 'rgba(136, 221, 136, 0.6)';
            ctx.beginPath();
            ctx.ellipse(x + 4, y + CONFIG.ENEMY_HEIGHT / 2, 6, 8, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + CONFIG.ENEMY_WIDTH - 4, y + CONFIG.ENEMY_HEIGHT / 2, 6, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x + CONFIG.ENEMY_WIDTH * 0.35, y + 8, 3, 0, Math.PI * 2);
            ctx.arc(x + CONFIG.ENEMY_WIDTH * 0.65, y + 8, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawButterfly(x, y) {
            ctx.fillStyle = CONFIG.COLORS.butterfly;
            // Body
            ctx.fillRect(x + CONFIG.ENEMY_WIDTH / 2 - 4, y + 4, 8, CONFIG.ENEMY_HEIGHT - 8);

            // Wings
            ctx.beginPath();
            ctx.moveTo(x + CONFIG.ENEMY_WIDTH / 2, y + 6);
            ctx.lineTo(x, y);
            ctx.lineTo(x, y + CONFIG.ENEMY_HEIGHT);
            ctx.lineTo(x + CONFIG.ENEMY_WIDTH / 2, y + CONFIG.ENEMY_HEIGHT - 6);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(x + CONFIG.ENEMY_WIDTH / 2, y + 6);
            ctx.lineTo(x + CONFIG.ENEMY_WIDTH, y);
            ctx.lineTo(x + CONFIG.ENEMY_WIDTH, y + CONFIG.ENEMY_HEIGHT);
            ctx.lineTo(x + CONFIG.ENEMY_WIDTH / 2, y + CONFIG.ENEMY_HEIGHT - 6);
            ctx.fill();

            // Wing patterns
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(x + 8, y + CONFIG.ENEMY_HEIGHT / 2, 5, 0, Math.PI * 2);
            ctx.arc(x + CONFIG.ENEMY_WIDTH - 8, y + CONFIG.ENEMY_HEIGHT / 2, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawBoss(x, y, health, hasCaptured) {
            const color = health === 1 ? CONFIG.COLORS.bossDamaged : CONFIG.COLORS.boss;
            ctx.fillStyle = color;

            // Main body
            ctx.beginPath();
            ctx.moveTo(x + CONFIG.BOSS_WIDTH / 2, y);
            ctx.lineTo(x + CONFIG.BOSS_WIDTH, y + CONFIG.BOSS_HEIGHT * 0.4);
            ctx.lineTo(x + CONFIG.BOSS_WIDTH * 0.8, y + CONFIG.BOSS_HEIGHT);
            ctx.lineTo(x + CONFIG.BOSS_WIDTH * 0.2, y + CONFIG.BOSS_HEIGHT);
            ctx.lineTo(x, y + CONFIG.BOSS_HEIGHT * 0.4);
            ctx.closePath();
            ctx.fill();

            // Crown detail
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(x + CONFIG.BOSS_WIDTH * 0.3, y + 4);
            ctx.lineTo(x + CONFIG.BOSS_WIDTH * 0.4, y + 10);
            ctx.lineTo(x + CONFIG.BOSS_WIDTH * 0.5, y + 4);
            ctx.lineTo(x + CONFIG.BOSS_WIDTH * 0.6, y + 10);
            ctx.lineTo(x + CONFIG.BOSS_WIDTH * 0.7, y + 4);
            ctx.stroke();

            // Eyes
            ctx.fillStyle = hasCaptured ? CONFIG.COLORS.capturedShip : '#fff';
            ctx.beginPath();
            ctx.arc(x + CONFIG.BOSS_WIDTH * 0.35, y + CONFIG.BOSS_HEIGHT * 0.5, 4, 0, Math.PI * 2);
            ctx.arc(x + CONFIG.BOSS_WIDTH * 0.65, y + CONFIG.BOSS_HEIGHT * 0.5, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawCapturedShip(x, y) {
            ctx.fillStyle = CONFIG.COLORS.capturedShip;
            ctx.beginPath();
            ctx.moveTo(x + CONFIG.PLAYER_WIDTH / 2, y + CONFIG.PLAYER_HEIGHT);
            ctx.lineTo(x + CONFIG.PLAYER_WIDTH, y);
            ctx.lineTo(x + CONFIG.PLAYER_WIDTH * 0.7, y + CONFIG.PLAYER_HEIGHT * 0.3);
            ctx.lineTo(x + CONFIG.PLAYER_WIDTH * 0.3, y + CONFIG.PLAYER_HEIGHT * 0.3);
            ctx.lineTo(x, y);
            ctx.closePath();
            ctx.fill();
        }

        function renderTractorBeam() {
            if (!tractorBeam) return;

            ctx.fillStyle = CONFIG.COLORS.tractorBeam;
            ctx.beginPath();
            ctx.moveTo(tractorBeam.x, tractorBeam.y);
            ctx.lineTo(tractorBeam.x + tractorBeam.width, tractorBeam.y);
            ctx.lineTo(tractorBeam.x + tractorBeam.width * 1.5, tractorBeam.y + tractorBeam.height);
            ctx.lineTo(tractorBeam.x - tractorBeam.width * 0.5, tractorBeam.y + tractorBeam.height);
            ctx.closePath();
            ctx.fill();

            // Beam lines
            ctx.strokeStyle = 'rgba(136, 255, 136, 0.5)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) {
                const t = (Date.now() / 100 + i * 20) % 100 / 100;
                const y = tractorBeam.y + tractorBeam.height * t;
                const width = tractorBeam.width * (1 + t * 0.5);
                ctx.beginPath();
                ctx.moveTo(tractorBeam.x + tractorBeam.width / 2 - width / 2, y);
                ctx.lineTo(tractorBeam.x + tractorBeam.width / 2 + width / 2, y);
                ctx.stroke();
            }
            ctx.lineWidth = 1;
        }

        function renderExplosions() {
            for (const exp of explosions) {
                for (const p of exp.particles) {
                    if (p.life <= 0) continue;

                    const alpha = p.life;
                    const hue = 30 + (1 - p.life) * 30; // Orange to red
                    ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function renderTitle() {
            renderBackground();
            renderStars();

            // Dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Title
            ctx.fillStyle = CONFIG.COLORS.textDanger;
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('STAR SQUADRON', CONFIG.WIDTH / 2, 150);

            // Subtitle
            ctx.fillStyle = CONFIG.COLORS.textHighlight;
            ctx.font = '18px Courier New';
            ctx.fillText('Defend the Galaxy!', CONFIG.WIDTH / 2, 190);

            // Instructions
            ctx.fillStyle = CONFIG.COLORS.text;
            ctx.font = '14px Courier New';
            ctx.fillText('Move: Arrow Keys / WASD', CONFIG.WIDTH / 2, 280);
            ctx.fillText('Fire: Space / Z', CONFIG.WIDTH / 2, 305);
            ctx.fillText('Pause: Escape / P', CONFIG.WIDTH / 2, 330);

            // Start prompt
            ctx.fillStyle = CONFIG.COLORS.textHighlight;
            ctx.font = 'bold 16px Courier New';
            const blink = Math.floor(Date.now() / 500) % 2;
            if (blink) {
                ctx.fillText('Press any button to start', CONFIG.WIDTH / 2, 400);
            }

            // High score
            if (gameData.highScore > 0) {
                ctx.fillStyle = CONFIG.COLORS.textHighlight;
                ctx.font = '14px Courier New';
                ctx.fillText(`High Score: ${gameData.highScore}`, CONFIG.WIDTH / 2, 440);
            }
        }

        function renderPlaying() {
            renderBackground();
            renderStars();
            renderBullets();
            renderEnemies();
            renderTractorBeam();
            renderPlayer();
            renderExplosions();
        }

        function renderStageComplete() {
            renderPlaying();

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = CONFIG.COLORS.textHighlight;
            ctx.font = 'bold 36px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`STAGE ${stage} COMPLETE!`, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2);
        }

        function renderChallengeComplete() {
            renderPlaying();

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = CONFIG.COLORS.textHighlight;
            ctx.font = 'bold 28px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('CHALLENGING STAGE', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 - 40);

            ctx.font = '20px Courier New';
            ctx.fillText(`Hits: ${challengeEnemiesHit} / ${challengeEnemiesTotal}`, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 10);

            if (challengeEnemiesHit === challengeEnemiesTotal) {
                ctx.fillStyle = CONFIG.COLORS.textDanger;
                ctx.font = 'bold 24px Courier New';
                ctx.fillText('PERFECT!', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 50);
                ctx.fillText(`+${CONFIG.PERFECT_BONUS} BONUS`, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 80);
            }
        }

        function renderPaused() {
            renderPlaying();

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = CONFIG.COLORS.textHighlight;
            ctx.font = 'bold 36px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2);

            ctx.font = '16px Courier New';
            ctx.fillStyle = CONFIG.COLORS.text;
            ctx.fillText('Press Start / Escape to resume', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 50);
        }

        function renderGameOver() {
            renderBackground();
            renderStars();

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = CONFIG.COLORS.textDanger;
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 - 60);

            ctx.fillStyle = CONFIG.COLORS.text;
            ctx.font = '24px Courier New';
            ctx.fillText(`Final Score: ${score}`, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2);
            ctx.fillText(`Stage Reached: ${stage}`, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 35);

            if (isNewHighScore) {
                ctx.fillStyle = CONFIG.COLORS.textHighlight;
                ctx.font = 'bold 20px Courier New';
                ctx.fillText('NEW HIGH SCORE!', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 80);
            }

            ctx.fillStyle = CONFIG.COLORS.text;
            ctx.font = '16px Courier New';
            const blink = Math.floor(Date.now() / 500) % 2;
            if (blink) {
                ctx.fillText('Press any button to continue', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 130);
            }
        }

        // ============================================
        // DISPLAY UPDATE
        // ============================================
        function updateDisplays() {
            document.getElementById('currentScore').textContent = score;
            document.getElementById('stageDisplay').textContent = stage;
            document.getElementById('livesDisplay').textContent = lives;
            document.getElementById('highScore').textContent = gameData.highScore;
        }

        // ============================================
        // MAIN GAME LOOP
        // ============================================
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            GameController.poll();

            switch (state) {
                case GameState.TITLE:
                    updateTitle();
                    renderTitle();
                    break;

                case GameState.ENTERING:
                    updateEntering(deltaTime);
                    renderPlaying();
                    break;

                case GameState.PLAYING:
                    updatePlaying(deltaTime);
                    renderPlaying();
                    break;

                case GameState.CAPTURING:
                    updateCapturing(deltaTime);
                    renderPlaying();
                    break;

                case GameState.CAPTURED:
                    updateCaptured(deltaTime);
                    renderPlaying();
                    break;

                case GameState.DYING:
                    updateDying(deltaTime);
                    renderPlaying();
                    break;

                case GameState.STAGE_COMPLETE:
                    updateStageComplete(deltaTime);
                    renderStageComplete();
                    break;

                case GameState.CHALLENGE_STAGE:
                    updateEntering(deltaTime);
                    renderPlaying();
                    break;

                case GameState.CHALLENGE_COMPLETE:
                    updateChallengeComplete(deltaTime);
                    renderChallengeComplete();
                    break;

                case GameState.PAUSED:
                    updatePaused(deltaTime);
                    renderPaused();
                    break;

                case GameState.GAME_OVER:
                    updateGameOver();
                    renderGameOver();
                    break;
            }

            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // INPUT HANDLERS
        // ============================================
        document.addEventListener('keydown', (e) => {
            if (e.repeat) return;

            if (state === GameState.TITLE || state === GameState.GAME_OVER) {
                startKeyPressed = true;
            }

            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                pauseKeyPressed = true;
            }
        });

        // Audio unlock
        const unlockAudio = () => {
            AudioSystem.unlock();
        };
        document.addEventListener('keydown', unlockAudio, { once: true });
        document.addEventListener('click', unlockAudio, { once: true });

        // Audio toggles
        document.getElementById('musicToggle').checked = gameData.musicEnabled;
        document.getElementById('sfxToggle').checked = gameData.sfxEnabled;

        document.getElementById('musicToggle').addEventListener('change', (e) => {
            AudioSystem.musicEnabled = e.target.checked;
            gameData.musicEnabled = e.target.checked;
            saveGameData();
            if (state === GameState.PLAYING || state === GameState.ENTERING) {
                if (e.target.checked) {
                    AudioSystem.music.start('invaders');
                } else {
                    AudioSystem.music.stop();
                }
            }
        });

        document.getElementById('sfxToggle').addEventListener('change', (e) => {
            AudioSystem.sfxEnabled = e.target.checked;
            gameData.sfxEnabled = e.target.checked;
            saveGameData();
        });

        // ============================================
        // INITIALIZATION
        // ============================================
        initStars();
        updateDisplays();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
