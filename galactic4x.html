<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic 4X</title>
    <link rel="icon" type="image/x-icon" href="https://oddturnip.com/favicon_turnip.ico">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #eee;
            padding: 10px;
        }
        h1 { margin-bottom: 10px; color: #4ecdc4; }
        #gameContainer {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }
        #centerColumn {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #gameCanvas {
            border: 4px solid #4a4a6a;
            border-radius: 4px;
            display: block;
            cursor: pointer;
        }
        #actionPanel {
            background: #1a1a2e;
            border: 4px solid #4a4a6a;
            border-radius: 4px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        #actionPanel.hidden { display: none; }
        .side-panel {
            width: 240px;
            background: #1a1a2e;
            border: 4px solid #4a4a6a;
            border-radius: 4px;
            padding: 12px;
            height: 620px;
            display: flex;
            flex-direction: column;
        }
        .side-panel.hidden { display: none; }
        .panel-title {
            color: #4ecdc4;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 6px;
            border-bottom: 1px solid #4a4a6a;
            padding-bottom: 4px;
        }
        .panel-subtitle {
            color: #888;
            font-size: 10px;
            margin-bottom: 8px;
        }
        .panel-content {
            flex: 1;
            overflow-y: auto;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            font-size: 10px;
        }
        .info-label { color: #888; }
        .info-value { color: #ffe66d; }
        .slider-container {
            margin: 6px 0;
            padding: 6px;
            background: #252540;
            border-radius: 4px;
        }
        .slider-container.locked-auto {
            background: #1a1a25;
            opacity: 0.6;
        }
        .slider-container.locked-noship {
            background: #2a2520;
            border: 1px solid #665500;
        }
        .slider-container.locked-user {
            background: #2a2a35;
            border: 1px solid #888;
        }
        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3px;
        }
        .slider-label {
            font-size: 10px;
            color: #888;
        }
        .slider-value {
            color: #4ecdc4;
            font-size: 10px;
            font-weight: bold;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .lock-btn {
            background: none;
            border: 1px solid #666;
            color: #666;
            width: 18px;
            height: 18px;
            font-size: 9px;
            cursor: pointer;
            border-radius: 3px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .lock-btn:hover { border-color: #888; color: #888; }
        .lock-btn.locked { border-color: #aaa; color: #aaa; background: #3a3a4a; }
        .lock-btn:disabled { cursor: not-allowed; opacity: 0.5; }
        .slider-production {
            font-size: 9px;
            color: #4a9;
            margin-top: 2px;
        }
        .lock-reason {
            font-size: 8px;
            color: #888;
            font-style: italic;
            margin-top: 1px;
        }
        .lock-reason.warning {
            color: #cc8800;
        }
        input[type="range"] {
            flex: 1;
            height: 14px;
            -webkit-appearance: none;
            background: #2a2a4a;
            border-radius: 4px;
            cursor: pointer;
        }
        input[type="range"]:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #4ecdc4;
            border-radius: 2px;
            cursor: pointer;
        }
        input[type="range"]:disabled::-webkit-slider-thumb {
            background: #666;
        }
        .btn {
            background: #2a2a4a;
            border: 2px solid #4ecdc4;
            color: #4ecdc4;
            padding: 6px 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            margin: 3px 2px;
            transition: all 0.2s;
        }
        .btn:hover:not(:disabled) {
            background: #4ecdc4;
            color: #1a1a2e;
        }
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .btn-sm {
            padding: 3px 6px;
            font-size: 9px;
            margin: 2px;
        }
        .btn-primary {
            background: #4ecdc4;
            color: #1a1a2e;
            font-weight: bold;
        }
        .btn-primary:hover:not(:disabled) {
            background: #6fefe6;
        }
        .btn-danger {
            border-color: #ff6b6b;
            color: #ff6b6b;
        }
        .btn-danger:hover:not(:disabled) {
            background: #ff6b6b;
            color: #1a1a2e;
        }
        .ship-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 6px;
            margin: 2px 0;
            background: #252540;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
        }
        .ship-item.selected {
            background: #2a4a4a;
            border: 1px solid #4ecdc4;
        }
        .build-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            margin: 8px 0;
        }
        .build-btn {
            padding: 4px;
            font-size: 9px;
        }
        #controls {
            margin-top: 10px;
            font-size: 10px;
            color: #888;
            text-align: center;
            max-width: 950px;
            line-height: 1.5;
        }
        #audioControls {
            margin-top: 8px;
            font-size: 11px;
            color: #888;
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        #audioControls label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #audioControls input[type="checkbox"] {
            cursor: pointer;
            accent-color: #4ecdc4;
        }
        #aboutSection {
            margin-top: 10px;
            max-width: 700px;
            background: #1a1a2e;
            border: 2px solid #4a4a6a;
            border-radius: 4px;
            padding: 12px;
        }
        #aboutSection h3 {
            color: #4ecdc4;
            font-size: 12px;
            margin-bottom: 8px;
        }
        #aboutSection p {
            font-size: 10px;
            color: #aaa;
            line-height: 1.4;
            margin-bottom: 6px;
        }
        #aboutSection strong {
            color: #ffe66d;
        }
        .travel-info {
            background: #252540;
            border: 1px solid #4a4a6a;
            border-radius: 4px;
            padding: 6px;
            margin: 6px 0;
            font-size: 10px;
        }
        .travel-info .distance { color: #4a9fff; }
        .travel-info .turns { color: #ffe66d; }
        .fleet-actions {
            margin-top: auto;
            padding-top: 8px;
            border-top: 1px solid #4a4a6a;
        }
        .empty-state {
            color: #666;
            font-size: 10px;
            text-align: center;
            padding: 20px 10px;
        }
        .destination-highlight {
            color: #ffe66d;
            font-size: 10px;
            margin: 6px 0;
            padding: 6px;
            background: #2a2520;
            border-radius: 4px;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <h1>Galactic 4X</h1>
    <div id="gameContainer">
        <div id="planetPanel" class="side-panel hidden">
            <div class="panel-title">Planet</div>
            <div id="planetContent" class="panel-content"></div>
        </div>
        <div id="centerColumn">
            <canvas id="gameCanvas" width="640" height="550"></canvas>
            <div id="actionPanel" class="hidden">
                <div style="display:flex;gap:10px;align-items:center;">
                    <button class="btn btn-primary" id="endTurnBtn" onclick="window.endTurn()">End Turn</button>
                    <button class="btn" onclick="window.showOverview()">Overview</button>
                </div>
                <div id="turnInfo" style="color:#888;font-size:11px;margin-top:6px;"></div>
            </div>
        </div>
        <div id="fleetPanel" class="side-panel hidden">
            <div class="panel-title">Fleets</div>
            <div id="fleetContent" class="panel-content"></div>
            <div class="fleet-actions" id="fleetActions"></div>
        </div>
    </div>
    <div id="controls">
        <strong>Mouse:</strong> Click stars to select | Select ships, then click destination | <strong>Keyboard:</strong> Enter = End Turn | Escape = Deselect
    </div>
    <div id="audioControls">
        <label><input type="checkbox" id="musicToggle" checked> Music</label>
        <label><input type="checkbox" id="sfxToggle" checked> Sound Effects</label>
    </div>
    <div id="aboutSection">
        <h3>How to Play</h3>
        <p><strong>Industry</strong> represents your colony's manufacturing capacity (0-100%). Higher industry = more production output per turn.</p>
        <p><strong>Population</strong> is your workforce. More population = more base production. Each planet has a max population based on its type.</p>
        <p><strong>Production Formula:</strong> Base = Population x (Industry/100) x Planet Modifier. This is split according to your sliders.</p>
        <p><strong>Slider Locks:</strong> Click ðŸ”“ to lock a slider. Locked sliders won't change when you adjust others.</p>
    </div>

    <script src="controller.js"></script>
    <script src="audio.js"></script>
    <script src="storage.js"></script>
    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            WIDTH: 640,
            HEIGHT: 550,
            STAR_COUNT: 24,
            MIN_STAR_DISTANCE: 60,
            PARSEC_SCALE: 10,
            COLORS: {
                background: '#0a0a1a',
                grid: '#1a1a2e',
                starYellow: '#ffe66d',
                starRed: '#ff6b6b',
                starBlue: '#4a9fff',
                starWhite: '#ffffff',
                text: '#ffffff',
                textHighlight: '#ffe66d',
                playerHighlight: '#4ecdc4',
                unexplored: '#666666',
                destination: '#ffe66d'
            }
        };

        const PLANET_TYPES = {
            terran: { name: 'Terran', maxPop: 100, industryMod: 1.0, ecoMod: 1.0, color: '#4ecdc4' },
            ocean: { name: 'Ocean', maxPop: 90, industryMod: 0.9, ecoMod: 1.1, color: '#4a9fff' },
            jungle: { name: 'Jungle', maxPop: 80, industryMod: 0.85, ecoMod: 1.2, color: '#2e8b57' },
            arid: { name: 'Arid', maxPop: 60, industryMod: 0.8, ecoMod: 0.7, color: '#daa520' },
            desert: { name: 'Desert', maxPop: 50, industryMod: 0.7, ecoMod: 0.6, color: '#c2b280' },
            tundra: { name: 'Tundra', maxPop: 40, industryMod: 0.6, ecoMod: 0.5, color: '#b0e0e6' },
            barren: { name: 'Barren', maxPop: 30, industryMod: 0.5, ecoMod: 0.3, color: '#808080' },
            inferno: { name: 'Inferno', maxPop: 20, industryMod: 0.4, ecoMod: 0.2, color: '#ff4500' },
            toxic: { name: 'Toxic', maxPop: 15, industryMod: 0.3, ecoMod: 0.1, color: '#7cfc00' }
        };

        const SHIP_TYPES = {
            scout: { name: 'Scout', cost: 30, speed: 3, attack: 1, defense: 1, icon: 'S' },
            fighter: { name: 'Fighter', cost: 60, speed: 2, attack: 4, defense: 2, icon: 'F' },
            destroyer: { name: 'Destroyer', cost: 120, speed: 2, attack: 8, defense: 6, icon: 'D' },
            colony: { name: 'Colony Ship', cost: 200, speed: 1, attack: 0, defense: 1, icon: 'C', colonize: true }
        };

        const RACES = [
            { id: 'terran', name: 'Terran Federation', color: '#4ecdc4', desc: 'Adaptable and expansionist humans' },
            { id: 'crystalline', name: 'Crystalline Collective', color: '#9932cc', desc: 'Silicon-based mineral lifeforms' },
            { id: 'aquan', name: 'Aquan Dominion', color: '#4a9fff', desc: 'Ocean-dwelling telepaths' },
            { id: 'hivemind', name: 'Hive Swarm', color: '#ffa500', desc: 'Unified insectoid consciousness' },
            { id: 'aviari', name: 'Aviari Consortium', color: '#ffe66d', desc: 'Elegant avian traders' },
            { id: 'saurian', name: 'Saurian Empire', color: '#ff6b6b', desc: 'Ancient reptilian warriors' }
        ];

        const STAR_NAMES = [
            'Sol', 'Alpha', 'Proxima', 'Vega', 'Sirius', 'Rigel', 'Deneb', 'Altair',
            'Polaris', 'Arcturus', 'Capella', 'Betelgeuse', 'Aldebaran', 'Antares',
            'Spica', 'Procyon', 'Canopus', 'Achernar', 'Hadar', 'Acrux', 'Mimosa',
            'Regulus', 'Adhara', 'Shaula', 'Castor', 'Bellatrix', 'Elnath', 'Miaplacidus',
            'Alnilam', 'Alnitak', 'Alioth', 'Dubhe', 'Mirfak', 'Wezen', 'Kaus', 'Sargas'
        ];

        // ============================================
        // PERSISTENCE
        // ============================================
        const GAME_ID = 'galactic4x';
        const SAVE_KEY = 'galactic4x_save';

        let gameData = GameStorage.load(GAME_ID, {
            ...GameStorage.defaults.arcade(),
            gamesWon: 0
        });

        function saveGameData() {
            GameStorage.save(GAME_ID, gameData);
        }

        function saveGameState() {
            if (state !== GameState.PLAYING) return;
            const saveData = {
                turn,
                player: { race: player.race, color: player.color },
                stars: stars.map(s => ({
                    id: s.id, name: s.name, x: s.x, y: s.y,
                    starType: s.starType, planetType: s.planetType,
                    owner: s.owner, explored: s.explored,
                    population: s.population, industry: s.industry, defense: s.defense,
                    sliders: {...s.sliders}, lockedSliders: [...(s.lockedSliders || [])],
                    shipProgress: {...s.shipProgress}, buildingShip: s.buildingShip,
                    colonizedTurn: s.colonizedTurn
                })),
                ships: ships.map(s => ({
                    id: s.id, type: s.type, owner: s.owner,
                    location: s.location, destination: s.destination,
                    turnsToArrival: s.turnsToArrival
                })),
                nextShipId
            };
            try {
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
            } catch (e) {
                console.warn('Failed to save game:', e);
            }
        }

        function loadGameState() {
            try {
                const saved = localStorage.getItem(SAVE_KEY);
                if (!saved) return false;
                const data = JSON.parse(saved);
                turn = data.turn;
                player.race = data.player.race;
                player.color = data.player.color;
                stars = data.stars.map(s => {
                    // Backwards compatibility: convert old number shipProgress to object
                    let shipProgress = s.shipProgress;
                    if (typeof shipProgress === 'number') {
                        shipProgress = { scout: 0, fighter: 0, destroyer: 0, colony: 0 };
                        if (s.buildingShip && shipProgress[s.buildingShip] !== undefined) {
                            shipProgress[s.buildingShip] = s.shipProgress;
                        }
                    }
                    return {
                        ...s,
                        lockedSliders: s.lockedSliders || [],
                        shipProgress: shipProgress || { scout: 0, fighter: 0, destroyer: 0, colony: 0 }
                    };
                });
                ships = data.ships;
                nextShipId = data.nextShipId;
                return true;
            } catch (e) {
                console.warn('Failed to load game:', e);
                return false;
            }
        }

        function clearSaveGame() {
            localStorage.removeItem(SAVE_KEY);
        }

        // ============================================
        // GAME STATE
        // ============================================
        const GameState = {
            TITLE: 'title',
            RACE_SELECT: 'race_select',
            PLAYING: 'playing',
            END_TURN: 'end_turn'
        };

        let state = GameState.TITLE;
        let turn = 1;

        let player = {
            race: null,
            color: '#4ecdc4'
        };

        let stars = [];
        let ships = [];
        let nextShipId = 1;

        // UI state
        let selectedStar = null;
        let selectedShips = [];
        let destinationStar = null; // NEW: target for move
        let hoveredStar = null;
        let raceSelectIndex = 0;
        let hasSaveGame = false;
        let overviewSort = 'name'; // 'name', 'age', 'dev', 'defense'

        // DOM references
        const planetPanel = document.getElementById('planetPanel');
        const planetContent = document.getElementById('planetContent');
        const fleetPanel = document.getElementById('fleetPanel');
        const fleetContent = document.getElementById('fleetContent');
        const fleetActions = document.getElementById('fleetActions');
        const actionPanel = document.getElementById('actionPanel');
        const turnInfo = document.getElementById('turnInfo');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ============================================
        // GALAXY GENERATION
        // ============================================
        function generateGalaxy() {
            stars = [];
            ships = [];
            nextShipId = 1;
            const shuffledNames = [...STAR_NAMES].sort(() => Math.random() - 0.5);

            for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
                let attempts = 0;
                let x, y, valid;

                do {
                    x = 50 + Math.random() * (CONFIG.WIDTH - 100);
                    y = 50 + Math.random() * (CONFIG.HEIGHT - 100);
                    valid = true;
                    for (const star of stars) {
                        const dist = Math.sqrt((x - star.x) ** 2 + (y - star.y) ** 2);
                        if (dist < CONFIG.MIN_STAR_DISTANCE) {
                            valid = false;
                            break;
                        }
                    }
                    attempts++;
                } while (!valid && attempts < 100);

                if (!valid) continue;

                const starTypes = ['yellow', 'red', 'blue', 'white'];
                const starType = starTypes[Math.floor(Math.random() * starTypes.length)];

                let planetType;
                const roll = Math.random();
                if (roll < 0.1) planetType = 'terran';
                else if (roll < 0.2) planetType = 'ocean';
                else if (roll < 0.35) planetType = 'jungle';
                else if (roll < 0.5) planetType = 'arid';
                else if (roll < 0.65) planetType = 'desert';
                else if (roll < 0.75) planetType = 'tundra';
                else if (roll < 0.85) planetType = 'barren';
                else if (roll < 0.93) planetType = 'inferno';
                else planetType = 'toxic';

                stars.push({
                    id: i,
                    name: shuffledNames[i] || `Star-${i}`,
                    x: x,
                    y: y,
                    starType: starType,
                    planetType: planetType,
                    owner: null,
                    explored: false,
                    population: 0,
                    industry: 0,
                    defense: 0,
                    // Default sliders: 50% eco, 50% industry (no ship production until queued)
                    sliders: { ship: 0, def: 0, ind: 50, eco: 50 },
                    lockedSliders: [],
                    shipProgress: { scout: 0, fighter: 0, destroyer: 0, colony: 0 },
                    buildingShip: null
                });
            }

            let homeStar = stars.find(s => s.planetType === 'terran') ||
                           stars.find(s => s.planetType === 'ocean') ||
                           stars[0];

            homeStar.owner = 'player';
            homeStar.explored = true;
            homeStar.population = 40;
            homeStar.industry = 20;
            homeStar.defense = 5;
            homeStar.planetType = 'terran';
            homeStar.colonizedTurn = 1;

            ships.push({
                id: nextShipId++,
                type: 'scout',
                owner: 'player',
                location: homeStar.id,
                destination: null,
                turnsToArrival: 0
            });
            ships.push({
                id: nextShipId++,
                type: 'scout',
                owner: 'player',
                location: homeStar.id,
                destination: null,
                turnsToArrival: 0
            });
            ships.push({
                id: nextShipId++,
                type: 'colony',
                owner: 'player',
                location: homeStar.id,
                destination: null,
                turnsToArrival: 0
            });
        }

        // ============================================
        // GAME LOGIC
        // ============================================
        function initGame() {
            turn = 1;
            selectedStar = null;
            selectedShips = [];
            destinationStar = null;
            generateGalaxy();
            actionPanel.classList.remove('hidden');
            planetPanel.classList.remove('hidden');
            fleetPanel.classList.remove('hidden');
            updateTurnInfo();
            updatePanels();
        }

        function updateTurnInfo() {
            const colonies = getPlayerColonies();
            const totalShips = ships.filter(s => s.owner === 'player').length;

            // Calculate total production and max production for player's colonies
            let totalProduction = 0;
            let maxColonyProduction = 0;

            for (const colony of colonies) {
                const planetInfo = PLANET_TYPES[colony.planetType];
                // Current production = population * (industry/100) * industryMod
                const colonyProd = colony.population * (colony.industry / 100) * planetInfo.industryMod;
                totalProduction += colonyProd;

                // Max production for this colony if fully developed
                maxColonyProduction += planetInfo.maxPop * 1.0 * planetInfo.industryMod;
            }

            // Calculate max possible production for entire map
            let maxMapProduction = 0;
            for (const star of stars) {
                const planetInfo = PLANET_TYPES[star.planetType];
                if (planetInfo.maxPop > 0) {
                    maxMapProduction += planetInfo.maxPop * 1.0 * planetInfo.industryMod;
                }
            }

            // Dev = how developed your colonies are (your prod / your max prod)
            // Conquest = how much of map you control (your prod / map max prod)
            const devPercent = maxColonyProduction > 0 ? Math.round((totalProduction / maxColonyProduction) * 100) : 0;
            const conquestPercent = maxMapProduction > 0 ? Math.round((totalProduction / maxMapProduction) * 100) : 0;

            turnInfo.textContent = `Turn ${turn} | Colonies: ${colonies.length} | Ships: ${totalShips} | Prod: ${Math.floor(totalProduction)}/turn | Dev: ${devPercent}% | Conquest: ${conquestPercent}%`;
        }

        function getShipsAtStar(starId) {
            return ships.filter(s => s.location === starId && s.destination === null);
        }

        function getPlayerColonies() {
            return stars.filter(s => s.owner === 'player');
        }

        function calculateProduction(star, overrideSliders = null) {
            if (star.owner !== 'player') return null;
            const planetInfo = PLANET_TYPES[star.planetType];
            const baseProduction = star.population * (star.industry / 100) * planetInfo.industryMod;
            const sliders = overrideSliders || star.sliders;
            return {
                ship: Math.floor(baseProduction * (sliders.ship / 100)),
                def: Math.floor(baseProduction * (sliders.def / 100)),
                ind: baseProduction * (sliders.ind / 100) * 0.5, // Keep decimal for gradual growth
                eco: baseProduction * (sliders.eco / 100) * planetInfo.ecoMod * 0.3
            };
        }

        function getSliderLockState(star, sliderKey) {
            if (star.lockedSliders && star.lockedSliders.includes(sliderKey)) {
                return { locked: true, type: 'user', reason: 'Locked by you' };
            }
            const planetInfo = PLANET_TYPES[star.planetType];
            if (sliderKey === 'ind' && star.industry >= 100) {
                return { locked: true, type: 'auto', reason: 'Industry maxed' };
            }
            if (sliderKey === 'eco' && star.population >= planetInfo.maxPop) {
                return { locked: true, type: 'auto', reason: 'Population maxed' };
            }
            if (sliderKey === 'ship' && !star.buildingShip) {
                return { locked: true, type: 'noship', reason: 'No ship queued' };
            }
            return { locked: false, type: null, reason: null };
        }

        function normalizeSliders(star, changedKey, newValue) {
            const lockStates = {};
            for (const key of Object.keys(star.sliders)) {
                lockStates[key] = getSliderLockState(star, key);
            }
            star.sliders[changedKey] = newValue;
            const unlockedKeys = Object.keys(star.sliders).filter(k =>
                k !== changedKey && !lockStates[k].locked
            );
            const total = Object.values(star.sliders).reduce((a, b) => a + b, 0);
            const diff = total - 100;
            if (diff === 0 || unlockedKeys.length === 0) return;
            const unlockedTotal = unlockedKeys.reduce((sum, k) => sum + star.sliders[k], 0);
            if (unlockedTotal === 0) {
                const perSlider = Math.floor(diff / unlockedKeys.length);
                for (const key of unlockedKeys) {
                    star.sliders[key] = Math.max(0, -perSlider);
                }
            } else {
                for (const key of unlockedKeys) {
                    const proportion = star.sliders[key] / unlockedTotal;
                    star.sliders[key] = Math.max(0, Math.round(star.sliders[key] - diff * proportion));
                }
            }
            const finalTotal = Object.values(star.sliders).reduce((a, b) => a + b, 0);
            if (finalTotal !== 100 && unlockedKeys.length > 0) {
                const adjustment = 100 - finalTotal;
                for (const key of unlockedKeys) {
                    if (star.sliders[key] > 0 || adjustment > 0) {
                        star.sliders[key] = Math.max(0, star.sliders[key] + adjustment);
                        break;
                    }
                }
            }
        }

        // When a slider becomes auto-locked (maxed), set it to 0 and redistribute
        function redistributeAutoLockedSliders(star) {
            const keys = ['ship', 'def', 'ind', 'eco'];
            let changed = false;

            for (const key of keys) {
                const lockState = getSliderLockState(star, key);
                // Only handle 'auto' locks (industry/population maxed)
                if (lockState.type === 'auto' && star.sliders[key] > 0) {
                    const valueToRedistribute = star.sliders[key];
                    star.sliders[key] = 0;
                    changed = true;

                    // Find sliders that can receive this value
                    // Priority: unlocked > noship > user-locked (override)
                    const otherKeys = keys.filter(k => k !== key);

                    // Get lock states for other sliders
                    const otherLockStates = {};
                    for (const k of otherKeys) {
                        otherLockStates[k] = getSliderLockState(star, k);
                    }

                    // Try unlocked sliders first
                    let receiverKeys = otherKeys.filter(k => !otherLockStates[k].locked);

                    // If no unlocked, try noship sliders
                    if (receiverKeys.length === 0) {
                        receiverKeys = otherKeys.filter(k => otherLockStates[k].type === 'noship');
                    }

                    // If still nothing, override user locks
                    if (receiverKeys.length === 0) {
                        receiverKeys = otherKeys.filter(k => otherLockStates[k].type === 'user');
                        // Remove the user lock since we're overriding it
                        for (const k of receiverKeys) {
                            if (star.lockedSliders) {
                                star.lockedSliders = star.lockedSliders.filter(l => l !== k);
                            }
                        }
                    }

                    // If still nothing (all other sliders are also auto-locked), skip
                    if (receiverKeys.length === 0) continue;

                    // Redistribute proportionally to current values, or equally if all zero
                    const receiverTotal = receiverKeys.reduce((sum, k) => sum + star.sliders[k], 0);
                    if (receiverTotal === 0) {
                        // Distribute equally
                        const perSlider = Math.floor(valueToRedistribute / receiverKeys.length);
                        let remainder = valueToRedistribute - (perSlider * receiverKeys.length);
                        for (const k of receiverKeys) {
                            star.sliders[k] += perSlider;
                            if (remainder > 0) {
                                star.sliders[k]++;
                                remainder--;
                            }
                        }
                    } else {
                        // Distribute proportionally
                        let distributed = 0;
                        for (let i = 0; i < receiverKeys.length; i++) {
                            const k = receiverKeys[i];
                            if (i === receiverKeys.length - 1) {
                                // Last one gets the remainder to ensure sum = 100
                                star.sliders[k] += (valueToRedistribute - distributed);
                            } else {
                                const proportion = star.sliders[k] / receiverTotal;
                                const amount = Math.round(valueToRedistribute * proportion);
                                star.sliders[k] += amount;
                                distributed += amount;
                            }
                        }
                    }
                }
            }

            return changed;
        }

        function processTurn() {
            state = GameState.END_TURN;

            for (const star of getPlayerColonies()) {
                const production = calculateProduction(star);
                const planetInfo = PLANET_TYPES[star.planetType];
                star.industry = Math.min(100, star.industry + production.ind);
                const maxPop = planetInfo.maxPop;
                if (star.population < maxPop) {
                    star.population = Math.min(maxPop, star.population + production.eco);
                }
                star.defense += production.def;
                if (star.buildingShip) {
                    const shipTypeKey = star.buildingShip;
                    star.shipProgress[shipTypeKey] += production.ship;
                    const shipType = SHIP_TYPES[shipTypeKey];
                    let shipsBuilt = 0;
                    // Build as many ships as production allows (with carry-over)
                    while (star.shipProgress[shipTypeKey] >= shipType.cost) {
                        ships.push({
                            id: nextShipId++,
                            type: shipTypeKey,
                            owner: 'player',
                            location: star.id,
                            destination: null,
                            turnsToArrival: 0
                        });
                        star.shipProgress[shipTypeKey] -= shipType.cost;
                        shipsBuilt++;
                    }
                    if (shipsBuilt > 0) {
                        AudioSystem.sfx.powerUp();
                    }
                    // Keep building same ship type (no longer sets to null)
                }
                // Redistribute sliders if industry or population just maxed
                redistributeAutoLockedSliders(star);
            }

            for (const ship of ships) {
                if (ship.destination !== null) {
                    ship.turnsToArrival--;
                    if (ship.turnsToArrival <= 0) {
                        ship.location = ship.destination;
                        ship.destination = null;
                        const star = stars.find(s => s.id === ship.location);
                        if (star && !star.explored) {
                            star.explored = true;
                            AudioSystem.sfx.select();
                        }
                    }
                }
            }

            turn++;
            state = GameState.PLAYING;
            updatePanels();
            updateTurnInfo();
            saveGameState();
        }

        function calculateTravelInfo(originStar, destStar, shipIds) {
            const dist = Math.sqrt((destStar.x - originStar.x) ** 2 + (destStar.y - originStar.y) ** 2);
            const lightYears = Math.round(dist / CONFIG.PARSEC_SCALE * 10) / 10;
            let slowestSpeed = Infinity;
            let slowestShipName = '';
            for (const shipId of shipIds) {
                const ship = ships.find(s => s.id === shipId);
                if (ship) {
                    const shipType = SHIP_TYPES[ship.type];
                    if (shipType.speed < slowestSpeed) {
                        slowestSpeed = shipType.speed;
                        slowestShipName = shipType.name;
                    }
                }
            }
            const turns = Math.max(1, Math.ceil(dist / (50 * slowestSpeed)));
            return { lightYears, turns, slowestShipName, slowestSpeed };
        }

        function moveShips(shipIds, destinationId) {
            const destStar = stars.find(s => s.id === destinationId);
            if (!destStar) return;
            for (const shipId of shipIds) {
                const ship = ships.find(s => s.id === shipId);
                if (!ship || ship.destination !== null) continue;
                const originStar = stars.find(s => s.id === ship.location);
                const shipType = SHIP_TYPES[ship.type];
                const dist = Math.sqrt((destStar.x - originStar.x) ** 2 + (destStar.y - originStar.y) ** 2);
                const turns = Math.ceil(dist / (50 * shipType.speed));
                ship.destination = destinationId;
                ship.turnsToArrival = Math.max(1, turns);
            }
            AudioSystem.sfx.select();
            selectedShips = [];
            destinationStar = null;
            updatePanels();
            saveGameState();
        }

        function colonizeStar(shipId, starId) {
            const ship = ships.find(s => s.id === shipId);
            const star = stars.find(s => s.id === starId);
            if (!ship || !star || ship.type !== 'colony' || star.owner !== null) return false;
            const planetInfo = PLANET_TYPES[star.planetType];
            if (planetInfo.maxPop === 0) return false;
            ships = ships.filter(s => s.id !== shipId);
            star.owner = 'player';
            star.explored = true;
            star.population = 10;
            star.industry = 5;
            star.defense = 0;
            star.lockedSliders = [];
            star.sliders = { ship: 0, def: 0, ind: 50, eco: 50 };
            star.colonizedTurn = turn;
            AudioSystem.sfx.levelComplete();
            updatePanels();
            updateTurnInfo();
            saveGameState();
            return true;
        }

        function startBuildingShip(starId, shipType) {
            const star = stars.find(s => s.id === starId);
            if (!star || star.owner !== 'player') return;
            star.buildingShip = shipType;
            // Don't reset progress - keep existing progress for this ship type
            AudioSystem.sfx.select();
            updatePanels();
            saveGameState();
        }

        function cancelBuildingShip(starId) {
            const star = stars.find(s => s.id === starId);
            if (!star) return;
            star.buildingShip = null;
            // Don't clear progress - it stays in the factories for later
            updatePanels();
            saveGameState();
        }

        // ============================================
        // UI UPDATES
        // ============================================
        function updatePanels() {
            updatePlanetPanel();
            updateFleetPanel();
        }

        function getColonyDevPercent(colony) {
            const planetInfo = PLANET_TYPES[colony.planetType];
            const prod = colony.population * (colony.industry / 100) * planetInfo.industryMod;
            const maxProd = planetInfo.maxPop * 1.0 * planetInfo.industryMod;
            return maxProd > 0 ? Math.round((prod / maxProd) * 100) : 0;
        }

        function updatePlanetPanel() {
            if (!selectedStar) {
                // Show empire overview
                let colonies = getPlayerColonies();
                let html = '<div class="panel-title">Empire Overview</div>';

                if (colonies.length === 0) {
                    html += '<div class="empty-state">No colonies yet</div>';
                } else {
                    // Sort buttons
                    html += '<div style="margin-bottom:6px;display:flex;gap:4px;flex-wrap:wrap;">';
                    const sortOptions = [
                        { key: 'name', label: 'Name' },
                        { key: 'age', label: 'Age' },
                        { key: 'dev', label: 'Dev' },
                        { key: 'defense', label: 'Def' }
                    ];
                    for (const opt of sortOptions) {
                        const active = overviewSort === opt.key ? 'background:#4ecdc4;color:#1a1a2e;' : '';
                        html += `<button class="btn btn-sm" style="padding:2px 6px;font-size:9px;${active}" onclick="setOverviewSort('${opt.key}')">${opt.label}</button>`;
                    }
                    html += '</div>';

                    // Sort colonies
                    colonies = [...colonies].sort((a, b) => {
                        switch (overviewSort) {
                            case 'name':
                                return a.name.localeCompare(b.name);
                            case 'age':
                                return (a.colonizedTurn || 1) - (b.colonizedTurn || 1);
                            case 'dev':
                                return getColonyDevPercent(b) - getColonyDevPercent(a);
                            case 'defense':
                                return b.defense - a.defense;
                            default:
                                return 0;
                        }
                    });

                    for (const colony of colonies) {
                        const planetInfo = PLANET_TYPES[colony.planetType];
                        const devPercent = getColonyDevPercent(colony);
                        const age = turn - (colony.colonizedTurn || 1);

                        html += `<div class="empire-planet" onclick="selectStar(${colony.id})" style="cursor:pointer;padding:6px;margin:4px 0;background:#252540;border-radius:4px;">`;
                        html += `<div style="color:${planetInfo.color};font-weight:bold;font-size:11px;">${colony.name} <span style="color:#888;font-weight:normal;">(${age})</span></div>`;
                        html += `<div style="font-size:10px;color:#888;">`;
                        html += `Dev: ${devPercent}% | Def: ${colony.defense}`;
                        html += `</div>`;

                        // Show ship production on separate row (only if producing)
                        if (colony.buildingShip) {
                            const prod = calculateProduction(colony);
                            if (prod.ship >= 1) {
                                const shipType = SHIP_TYPES[colony.buildingShip];
                                const progress = colony.shipProgress[colony.buildingShip] || 0;
                                const pct = Math.floor((progress / shipType.cost) * 100);
                                const shipsPerTurn = prod.ship / shipType.cost;

                                html += `<div style="font-size:10px;color:#4ecdc4;">`;
                                html += `${shipType.name}: ${pct}%`;
                                if (shipsPerTurn >= 0.01) {
                                    html += ` (${shipsPerTurn.toFixed(2)}/turn)`;
                                }
                                html += `</div>`;
                            }
                        }
                        html += `</div>`;
                    }
                }

                planetContent.innerHTML = html;
                return;
            }

            const star = selectedStar;
            let html = '';

            html += `<div class="panel-subtitle">${star.name}</div>`;

            if (star.explored) {
                const planetInfo = PLANET_TYPES[star.planetType];
                html += `<div class="info-row"><span class="info-label">Type:</span><span class="info-value" style="color:${planetInfo.color}">${planetInfo.name}</span></div>`;
                html += `<div class="info-row"><span class="info-label">Max Pop:</span><span class="info-value">${planetInfo.maxPop}</span></div>`;
            } else {
                html += `<div class="info-row"><span class="info-label">Type:</span><span class="info-value" style="color:#666">Unknown</span></div>`;
                html += `<div class="info-row"><span class="info-label">Max Pop:</span><span class="info-value" style="color:#666">???</span></div>`;
            }

            if (star.owner === 'player') {
                // Ensure auto-locked sliders are at 0 and redistributed
                redistributeAutoLockedSliders(star);

                const planetInfo = PLANET_TYPES[star.planetType];
                const prod = calculateProduction(star);

                html += `<div style="margin-top:10px" class="panel-title">Colony</div>`;
                html += `<div class="info-row"><span class="info-label">Population:</span><span class="info-value">${star.population.toFixed(1)}/${planetInfo.maxPop}</span></div>`;
                html += `<div class="info-row"><span class="info-label">Industry:</span><span class="info-value">${star.industry.toFixed(1)}%</span></div>`;
                html += `<div class="info-row"><span class="info-label">Defense:</span><span class="info-value">${star.defense}</span></div>`;

                html += `<div style="margin-top:10px" class="panel-title">Production</div>`;

                const sliderTypes = [
                    { key: 'ship', label: 'Ships', prodKey: 'ship', prodLabel: 'prod' },
                    { key: 'def', label: 'Defense', prodKey: 'def', prodLabel: 'def' },
                    { key: 'ind', label: 'Industry', prodKey: 'ind', prodLabel: '% ind' },
                    { key: 'eco', label: 'Growth', prodKey: 'eco', prodLabel: 'pop' }
                ];

                for (const slider of sliderTypes) {
                    const lockState = getSliderLockState(star, slider.key);
                    let containerClass = 'slider-container';
                    if (lockState.locked) {
                        if (lockState.type === 'auto') containerClass += ' locked-auto';
                        else if (lockState.type === 'noship') containerClass += ' locked-noship';
                        else if (lockState.type === 'user') containerClass += ' locked-user';
                    }
                    const isUserLocked = star.lockedSliders && star.lockedSliders.includes(slider.key);
                    const lockBtnClass = isUserLocked ? 'lock-btn locked' : 'lock-btn';
                    const lockDisabled = lockState.type === 'auto' || lockState.type === 'noship';

                    // Determine if we should show production (hide if maxed)
                    const isMaxed = (slider.key === 'ind' && star.industry >= 100) ||
                                   (slider.key === 'eco' && star.population >= planetInfo.maxPop);

                    // Format production value (1 decimal for pop/industry growth)
                    // Hide ship production if less than 1
                    let prodDisplay = '';
                    if (!isMaxed) {
                        if (slider.key === 'ship' && prod.ship < 1) {
                            // Don't show ship production less than 1
                        } else if (slider.key === 'eco' || slider.key === 'ind') {
                            prodDisplay = `+${prod[slider.prodKey].toFixed(1)} ${slider.prodLabel}/turn`;
                        } else {
                            prodDisplay = `+${prod[slider.prodKey]} ${slider.prodLabel}/turn`;
                        }
                    }

                    html += `<div class="${containerClass}" data-slider="${slider.key}">
                        <div class="slider-header">
                            <span class="slider-label">${slider.label}</span>
                            <span class="slider-value" id="slider-val-${star.id}-${slider.key}">${star.sliders[slider.key]}%</span>
                        </div>
                        <div class="slider-row">
                            <input type="range" min="0" max="100" step="5" value="${star.sliders[slider.key]}"
                                   ${lockState.locked ? 'disabled' : ''}
                                   oninput="previewSlider(${star.id}, '${slider.key}', this.value)"
                                   onchange="adjustSlider(${star.id}, '${slider.key}', this.value)">
                            <button class="${lockBtnClass}" ${lockDisabled ? 'disabled' : ''}
                                    onclick="toggleSliderLock(${star.id}, '${slider.key}')">
                                ${isUserLocked ? 'ðŸ”’' : 'ðŸ”“'}
                            </button>
                        </div>
                        <div class="slider-production" id="slider-prod-${star.id}-${slider.key}">${prodDisplay}</div>`;
                    if (lockState.locked && lockState.reason) {
                        const reasonClass = lockState.type === 'noship' ? 'lock-reason warning' : 'lock-reason';
                        const prefix = lockState.type === 'noship' ? 'âš  ' : '';
                        html += `<div class="${reasonClass}">${prefix}${lockState.reason}</div>`;
                    }
                    html += `</div>`;
                }

                html += `<div style="margin-top:10px" class="panel-title">Shipyard</div>`;
                if (star.buildingShip) {
                    const shipTypeKey = star.buildingShip;
                    const shipType = SHIP_TYPES[shipTypeKey];
                    const currentProgress = star.shipProgress[shipTypeKey] || 0;
                    const progress = Math.floor((currentProgress / shipType.cost) * 100);
                    const remaining = shipType.cost - currentProgress;

                    // Calculate ships per turn and next turn output
                    let shipsNextTurn = 0;
                    let turnsLeft = 'âˆž';
                    if (prod.ship > 0) {
                        const totalNextTurn = currentProgress + prod.ship;
                        shipsNextTurn = Math.floor(totalNextTurn / shipType.cost);
                        const leftoverAfterBuilding = totalNextTurn - (shipsNextTurn * shipType.cost);
                        turnsLeft = Math.ceil(remaining / prod.ship);
                    }

                    html += `<div class="info-row"><span class="info-label">Building:</span><span class="info-value">${shipType.name}</span></div>`;
                    html += `<div class="info-row"><span class="info-label">Progress:</span><span class="info-value">${currentProgress}/${shipType.cost} (${progress}%)</span></div>`;
                    if (prod.ship > 0) {
                        html += `<div class="info-row"><span class="info-label">+Production:</span><span class="info-value">+${prod.ship}/turn</span></div>`;
                        if (shipsNextTurn > 0) {
                            html += `<div class="info-row"><span class="info-label">Next turn:</span><span class="info-value" style="color:#4ecdc4">${shipsNextTurn} ship${shipsNextTurn > 1 ? 's' : ''}</span></div>`;
                        } else {
                            html += `<div class="info-row"><span class="info-label">ETA:</span><span class="info-value">${turnsLeft} turn${turnsLeft > 1 ? 's' : ''}</span></div>`;
                        }
                    } else {
                        html += `<div class="info-row"><span class="info-label">ETA:</span><span class="info-value">âˆž (0% allocated)</span></div>`;
                    }
                    html += `<button class="btn btn-danger btn-sm" onclick="cancelBuildingShip(${star.id})">Cancel</button>`;
                } else {
                    html += `<div class="build-options">`;
                    for (const [key, type] of Object.entries(SHIP_TYPES)) {
                        const existingProgress = star.shipProgress[key] || 0;
                        let label = `${type.name}<br>(${type.cost})`;
                        if (existingProgress > 0) {
                            label = `${type.name}<br>(${existingProgress}/${type.cost})`;
                        }
                        html += `<button class="btn build-btn" onclick="startBuildingShip(${star.id}, '${key}')">${label}</button>`;
                    }
                    html += `</div>`;
                }
            } else if (star.explored) {
                const planetInfo = PLANET_TYPES[star.planetType];
                html += `<div style="margin-top:10px;color:#888;font-size:10px">Unclaimed system</div>`;
                const playerShips = getShipsAtStar(star.id).filter(s => s.owner === 'player');
                const colonyShip = playerShips.find(s => s.type === 'colony');
                if (colonyShip && planetInfo.maxPop > 0) {
                    html += `<button class="btn" style="margin-top:8px" onclick="colonizeStar(${colonyShip.id}, ${star.id})">Colonize</button>`;
                } else if (planetInfo.maxPop === 0) {
                    html += `<div style="color:#ff6b6b;font-size:10px;margin-top:5px">Uninhabitable</div>`;
                }
            } else {
                html += `<div style="margin-top:10px;color:#888;font-size:10px">Unexplored - send a ship</div>`;
            }

            planetContent.innerHTML = html;
        }

        function updateFleetPanel() {
            if (!selectedStar) {
                // Show fleet overview grouped by location
                const playerShips = ships.filter(s => s.owner === 'player');
                let html = '<div class="panel-title">Fleet Overview</div>';

                if (playerShips.length === 0) {
                    html += '<div class="empty-state">No ships yet</div>';
                } else {
                    // Group ships by location (and destination for in-transit)
                    const locations = new Map(); // starId -> { stationed: [], incoming: [] }

                    for (const ship of playerShips) {
                        if (ship.destination !== null) {
                            // In transit - group by destination
                            if (!locations.has(ship.destination)) {
                                locations.set(ship.destination, { stationed: [], incoming: [] });
                            }
                            locations.get(ship.destination).incoming.push(ship);
                        } else {
                            // Stationed
                            if (!locations.has(ship.location)) {
                                locations.set(ship.location, { stationed: [], incoming: [] });
                            }
                            locations.get(ship.location).stationed.push(ship);
                        }
                    }

                    // Sort by star name
                    const sortedLocations = [...locations.entries()].sort((a, b) => {
                        const starA = stars.find(s => s.id === a[0]);
                        const starB = stars.find(s => s.id === b[0]);
                        return (starA?.name || '').localeCompare(starB?.name || '');
                    });

                    for (const [starId, fleets] of sortedLocations) {
                        const star = stars.find(s => s.id === starId);
                        if (!star) continue;

                        html += `<div class="fleet-location" onclick="selectStar(${starId})" style="cursor:pointer;padding:6px;margin:4px 0;background:#252540;border-radius:4px;">`;
                        html += `<div style="color:#4ecdc4;font-weight:bold;font-size:11px;">${star.name}</div>`;

                        // Count ships by type for stationed
                        if (fleets.stationed.length > 0) {
                            const counts = {};
                            for (const ship of fleets.stationed) {
                                counts[ship.type] = (counts[ship.type] || 0) + 1;
                            }
                            const parts = [];
                            for (const [type, count] of Object.entries(counts)) {
                                parts.push(`${count} ${SHIP_TYPES[type].name}${count > 1 ? 's' : ''}`);
                            }
                            html += `<div style="font-size:10px;color:#888;">${parts.join(', ')}</div>`;
                        }

                        // Count ships by type for incoming
                        if (fleets.incoming.length > 0) {
                            const counts = {};
                            let maxEta = 0;
                            for (const ship of fleets.incoming) {
                                counts[ship.type] = (counts[ship.type] || 0) + 1;
                                maxEta = Math.max(maxEta, ship.turnsToArrival);
                            }
                            const parts = [];
                            for (const [type, count] of Object.entries(counts)) {
                                parts.push(`${count} ${SHIP_TYPES[type].name}${count > 1 ? 's' : ''}`);
                            }
                            html += `<div style="font-size:10px;color:#ffe66d;">â†’ ${parts.join(', ')} (${maxEta}t)</div>`;
                        }

                        html += `</div>`;
                    }
                }

                fleetContent.innerHTML = html;
                fleetActions.innerHTML = '';
                return;
            }

            const star = selectedStar;
            const shipsHere = getShipsAtStar(star.id).filter(s => s.owner === 'player');
            const incomingShips = ships.filter(s => s.destination === star.id && s.owner === 'player');

            let html = '';
            html += `<div class="panel-subtitle">${star.name}</div>`;

            if (shipsHere.length > 0) {
                // Group ships by type
                const shipsByType = {};
                for (const ship of shipsHere) {
                    if (!shipsByType[ship.type]) {
                        shipsByType[ship.type] = [];
                    }
                    shipsByType[ship.type].push(ship);
                }

                // Count selected by type
                const selectedByType = {};
                for (const shipId of selectedShips) {
                    const ship = shipsHere.find(s => s.id === shipId);
                    if (ship) {
                        selectedByType[ship.type] = (selectedByType[ship.type] || 0) + 1;
                    }
                }

                const totalSelected = selectedShips.length;
                html += `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                    <span style="font-size:10px;color:#888">Selected: ${totalSelected}/${shipsHere.length}</span>
                    <button class="btn btn-sm" onclick="toggleSelectAll()">${totalSelected === shipsHere.length ? 'Clear' : 'All'}</button>
                </div>`;

                // Show each ship type with selection controls
                for (const [type, typeShips] of Object.entries(shipsByType)) {
                    const shipType = SHIP_TYPES[type];
                    const count = typeShips.length;
                    const selected = selectedByType[type] || 0;

                    html += `<div style="background:#252540;border-radius:4px;padding:6px;margin:4px 0;">`;
                    html += `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">`;
                    html += `<span style="font-size:11px;font-weight:bold;">${shipType.name}</span>`;
                    html += `<span style="font-size:10px;color:#888;">${selected}/${count}</span>`;
                    html += `</div>`;

                    // Quick select buttons
                    html += `<div style="display:flex;gap:3px;flex-wrap:wrap;margin-bottom:4px;">`;
                    html += `<button class="btn btn-sm" style="padding:1px 4px;font-size:9px;" onclick="selectShipsOfType('${type}', 1)">+1</button>`;
                    html += `<button class="btn btn-sm" style="padding:1px 4px;font-size:9px;" onclick="selectShipsOfType('${type}', 10)">+10</button>`;
                    html += `<button class="btn btn-sm" style="padding:1px 4px;font-size:9px;" onclick="selectShipsOfType('${type}', 100)">+100</button>`;
                    html += `<button class="btn btn-sm" style="padding:1px 4px;font-size:9px;" onclick="deselectShipsOfType('${type}', 1)">-1</button>`;
                    html += `<button class="btn btn-sm" style="padding:1px 4px;font-size:9px;" onclick="deselectShipsOfType('${type}', ${count})">None</button>`;
                    html += `</div>`;

                    // Slider for this type
                    html += `<input type="range" min="0" max="${count}" value="${selected}" style="width:100%;"
                               oninput="setShipTypeSelection('${type}', parseInt(this.value))">`;
                    html += `</div>`;
                }
            } else {
                html += `<div class="empty-state">No ships at this location</div>`;
            }

            if (incomingShips.length > 0) {
                html += `<div style="margin-top:10px" class="panel-title">Incoming</div>`;
                // Group incoming by type too
                const incomingByType = {};
                for (const ship of incomingShips) {
                    if (!incomingByType[ship.type]) {
                        incomingByType[ship.type] = { count: 0, minTurns: Infinity };
                    }
                    incomingByType[ship.type].count++;
                    incomingByType[ship.type].minTurns = Math.min(incomingByType[ship.type].minTurns, ship.turnsToArrival);
                }
                for (const [type, info] of Object.entries(incomingByType)) {
                    const shipType = SHIP_TYPES[type];
                    html += `<div class="ship-item">
                        <span>${info.count}x ${shipType.name}</span>
                        <span style="color:#ffe66d">${info.minTurns}t</span>
                    </div>`;
                }
            }

            fleetContent.innerHTML = html;

            // Fleet actions
            let actionsHtml = '';
            const hasSelection = selectedShips.length > 0;

            if (destinationStar && hasSelection) {
                const travelInfo = calculateTravelInfo(selectedStar, destinationStar, selectedShips);
                actionsHtml += `<div class="destination-highlight">
                    <div>To: <strong>${destinationStar.name}</strong></div>
                    <div><span class="distance">${travelInfo.lightYears} LY</span> - <span class="turns">${travelInfo.turns} turns</span></div>
                    ${selectedShips.length > 1 ? `<div style="font-size:9px;color:#888">Slowest: ${travelInfo.slowestShipName}</div>` : ''}
                </div>`;
                actionsHtml += `<button class="btn btn-primary" onclick="confirmMove()">Confirm Move</button>`;
                actionsHtml += `<button class="btn btn-danger btn-sm" onclick="cancelMove()">Cancel</button>`;
            } else {
                actionsHtml += `<button class="btn" ${hasSelection ? '' : 'disabled'} onclick="window.focus()">Move ${hasSelection ? selectedShips.length + ' Ship' + (selectedShips.length > 1 ? 's' : '') : 'Ships'}</button>`;
                if (hasSelection) {
                    actionsHtml += `<div style="font-size:9px;color:#888;margin-top:4px">Click a destination star</div>`;
                }
            }

            fleetActions.innerHTML = actionsHtml;
        }

        // Global functions for UI callbacks
        window.previewSlider = function(starId, sliderKey, value) {
            const star = stars.find(s => s.id === starId);
            if (!star) return;
            value = parseInt(value);

            // Create a temporary copy of sliders to calculate preview
            const tempSliders = {...star.sliders};
            tempSliders[sliderKey] = value;

            // Calculate how other sliders would adjust
            const lockStates = {};
            for (const key of Object.keys(star.sliders)) {
                lockStates[key] = getSliderLockState(star, key);
            }
            const unlockedKeys = Object.keys(star.sliders).filter(k =>
                k !== sliderKey && !lockStates[k].locked
            );
            const total = Object.values(tempSliders).reduce((a, b) => a + b, 0);
            const diff = total - 100;

            if (diff !== 0 && unlockedKeys.length > 0) {
                const unlockedTotal = unlockedKeys.reduce((sum, k) => sum + tempSliders[k], 0);
                if (unlockedTotal === 0) {
                    const perSlider = Math.floor(diff / unlockedKeys.length);
                    for (const key of unlockedKeys) {
                        tempSliders[key] = Math.max(0, -perSlider);
                    }
                } else {
                    for (const key of unlockedKeys) {
                        const proportion = tempSliders[key] / unlockedTotal;
                        tempSliders[key] = Math.max(0, Math.round(tempSliders[key] - diff * proportion));
                    }
                }
                // Fix rounding
                const finalTotal = Object.values(tempSliders).reduce((a, b) => a + b, 0);
                if (finalTotal !== 100 && unlockedKeys.length > 0) {
                    tempSliders[unlockedKeys[0]] += (100 - finalTotal);
                }
            }

            // Calculate preview production
            const prod = calculateProduction(star, tempSliders);
            const planetInfo = PLANET_TYPES[star.planetType];

            // Update all slider displays
            const sliderTypes = [
                { key: 'ship', prodKey: 'ship', prodLabel: 'prod' },
                { key: 'def', prodKey: 'def', prodLabel: 'def' },
                { key: 'ind', prodKey: 'ind', prodLabel: '% ind' },
                { key: 'eco', prodKey: 'eco', prodLabel: 'pop' }
            ];

            for (const slider of sliderTypes) {
                const valEl = document.getElementById(`slider-val-${starId}-${slider.key}`);
                const prodEl = document.getElementById(`slider-prod-${starId}-${slider.key}`);
                if (valEl) valEl.textContent = `${tempSliders[slider.key]}%`;
                if (prodEl) {
                    const isMaxed = (slider.key === 'ind' && star.industry >= 100) ||
                                   (slider.key === 'eco' && star.population >= planetInfo.maxPop);
                    if (!isMaxed) {
                        if (slider.key === 'eco' || slider.key === 'ind') {
                            prodEl.textContent = `+${prod[slider.prodKey].toFixed(1)} ${slider.prodLabel}/turn`;
                        } else {
                            prodEl.textContent = `+${prod[slider.prodKey]} ${slider.prodLabel}/turn`;
                        }
                    }
                }
            }
        };

        window.adjustSlider = function(starId, sliderKey, value) {
            const star = stars.find(s => s.id === starId);
            if (!star) return;
            value = parseInt(value);
            normalizeSliders(star, sliderKey, value);
            updatePanels();
            saveGameState();
        };

        window.setOverviewSort = function(sortKey) {
            overviewSort = sortKey;
            updatePanels();
        };

        window.toggleSliderLock = function(starId, sliderKey) {
            const star = stars.find(s => s.id === starId);
            if (!star) return;
            if (!star.lockedSliders) star.lockedSliders = [];
            const idx = star.lockedSliders.indexOf(sliderKey);
            if (idx >= 0) {
                star.lockedSliders.splice(idx, 1);
            } else {
                star.lockedSliders.push(sliderKey);
            }
            updatePanels();
            saveGameState();
        };

        window.selectStar = function(starId) {
            const star = stars.find(s => s.id === starId);
            if (!star) return;
            selectedStar = star;
            selectedShips = [];
            destinationStar = null;
            updatePanels();
            draw();
        };

        window.showOverview = function() {
            selectedStar = null;
            selectedShips = [];
            destinationStar = null;
            updatePanels();
            draw();
        };

        window.toggleShipSelection = function(shipId) {
            const idx = selectedShips.indexOf(shipId);
            if (idx >= 0) {
                selectedShips.splice(idx, 1);
            } else {
                selectedShips.push(shipId);
            }
            // Clear destination when selection changes
            destinationStar = null;
            updatePanels();
        };

        window.toggleSelectAll = function() {
            const shipsHere = getShipsAtStar(selectedStar.id).filter(s => s.owner === 'player');
            if (selectedShips.length === shipsHere.length) {
                selectedShips = [];
            } else {
                selectedShips = shipsHere.map(s => s.id);
            }
            destinationStar = null;
            updatePanels();
        };

        window.selectShipsOfType = function(type, count) {
            if (!selectedStar) return;
            const shipsHere = getShipsAtStar(selectedStar.id).filter(s => s.owner === 'player' && s.type === type);
            let added = 0;
            for (const ship of shipsHere) {
                if (added >= count) break;
                if (!selectedShips.includes(ship.id)) {
                    selectedShips.push(ship.id);
                    added++;
                }
            }
            destinationStar = null;
            updatePanels();
        };

        window.deselectShipsOfType = function(type, count) {
            if (!selectedStar) return;
            const shipsHere = getShipsAtStar(selectedStar.id).filter(s => s.owner === 'player' && s.type === type);
            let removed = 0;
            for (const ship of shipsHere) {
                if (removed >= count) break;
                const idx = selectedShips.indexOf(ship.id);
                if (idx >= 0) {
                    selectedShips.splice(idx, 1);
                    removed++;
                }
            }
            destinationStar = null;
            updatePanels();
        };

        window.setShipTypeSelection = function(type, targetCount) {
            if (!selectedStar) return;
            const shipsHere = getShipsAtStar(selectedStar.id).filter(s => s.owner === 'player' && s.type === type);

            // Count currently selected of this type
            let currentCount = 0;
            for (const ship of shipsHere) {
                if (selectedShips.includes(ship.id)) currentCount++;
            }

            if (targetCount > currentCount) {
                // Add more
                for (const ship of shipsHere) {
                    if (currentCount >= targetCount) break;
                    if (!selectedShips.includes(ship.id)) {
                        selectedShips.push(ship.id);
                        currentCount++;
                    }
                }
            } else if (targetCount < currentCount) {
                // Remove some
                for (const ship of shipsHere) {
                    if (currentCount <= targetCount) break;
                    const idx = selectedShips.indexOf(ship.id);
                    if (idx >= 0) {
                        selectedShips.splice(idx, 1);
                        currentCount--;
                    }
                }
            }
            destinationStar = null;
            updatePanels();
        };

        window.confirmMove = function() {
            if (destinationStar && selectedShips.length > 0) {
                moveShips(selectedShips, destinationStar.id);
            }
        };

        window.cancelMove = function() {
            destinationStar = null;
            updatePanels();
        };

        window.endTurn = function() {
            processTurn();
            AudioSystem.sfx.select();
        };

        window.startBuildingShip = startBuildingShip;
        window.cancelBuildingShip = cancelBuildingShip;
        window.colonizeStar = colonizeStar;

        // ============================================
        // INPUT HANDLING
        // ============================================
        function getStarAtPosition(x, y) {
            for (const star of stars) {
                const dist = Math.sqrt((x - star.x) ** 2 + (y - star.y) ** 2);
                if (dist < 20) {
                    return star;
                }
            }
            return null;
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - 4; // Account for 4px border
            const y = e.clientY - rect.top - 4;

            AudioSystem.unlock();

            if (state === GameState.TITLE) {
                if (hasSaveGame && y >= CONFIG.HEIGHT / 2 + 30 && y <= CONFIG.HEIGHT / 2 + 60) {
                    if (loadGameState()) {
                        state = GameState.PLAYING;
                        actionPanel.classList.remove('hidden');
                        planetPanel.classList.remove('hidden');
                        fleetPanel.classList.remove('hidden');
                        updateTurnInfo();
                        updatePanels();
                        AudioSystem.sfx.select();
                        return;
                    }
                }
                if (hasSaveGame && y >= CONFIG.HEIGHT / 2 + 70 && y <= CONFIG.HEIGHT / 2 + 100) {
                    clearSaveGame();
                    state = GameState.RACE_SELECT;
                    AudioSystem.sfx.select();
                    return;
                }
                if (!hasSaveGame) {
                    state = GameState.RACE_SELECT;
                    AudioSystem.sfx.select();
                }
                return;
            }

            if (state === GameState.RACE_SELECT) {
                const raceY = 120;
                const raceHeight = 50;
                for (let i = 0; i < RACES.length; i++) {
                    const ry = raceY + i * raceHeight;
                    if (y >= ry && y < ry + raceHeight && x >= 100 && x <= CONFIG.WIDTH - 100) {
                        player.race = RACES[i];
                        player.color = RACES[i].color;
                        initGame();
                        state = GameState.PLAYING;
                        AudioSystem.sfx.levelComplete();
                        saveGameState();
                        return;
                    }
                }
                return;
            }

            if (state === GameState.PLAYING) {
                const clickedStar = getStarAtPosition(x, y);

                // If ships are selected and we click a different star, set it as destination
                if (selectedShips.length > 0 && clickedStar && clickedStar !== selectedStar) {
                    destinationStar = clickedStar;
                    AudioSystem.sfx.select();
                    updatePanels();
                    return;
                }

                // Otherwise, select the star (or deselect if clicking empty space)
                if (clickedStar) {
                    selectedStar = clickedStar;
                    selectedShips = [];
                    destinationStar = null;
                    AudioSystem.sfx.select();
                    updatePanels();
                } else if (selectedShips.length === 0) {
                    // Only deselect if no ships are selected (preserve selection for movement)
                    selectedStar = null;
                    destinationStar = null;
                    updatePanels();
                }
                // If ships are selected and clicking empty space, do nothing (keep selection)
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - 4; // Account for 4px border
            const y = e.clientY - rect.top - 4;
            if (state === GameState.PLAYING) {
                hoveredStar = getStarAtPosition(x, y);
            }
        });

        document.addEventListener('keydown', (e) => {
            AudioSystem.unlock();

            if (state === GameState.TITLE) {
                if (e.key === 'Enter' || e.key === ' ') {
                    if (hasSaveGame && loadGameState()) {
                        state = GameState.PLAYING;
                        actionPanel.classList.remove('hidden');
                        planetPanel.classList.remove('hidden');
                        fleetPanel.classList.remove('hidden');
                        updateTurnInfo();
                        updatePanels();
                        AudioSystem.sfx.select();
                    } else {
                        state = GameState.RACE_SELECT;
                        AudioSystem.sfx.select();
                    }
                }
                return;
            }

            if (state === GameState.RACE_SELECT) {
                if (e.key === 'ArrowUp') {
                    raceSelectIndex = (raceSelectIndex - 1 + RACES.length) % RACES.length;
                    AudioSystem.sfx.select();
                } else if (e.key === 'ArrowDown') {
                    raceSelectIndex = (raceSelectIndex + 1) % RACES.length;
                    AudioSystem.sfx.select();
                } else if (e.key === 'Enter' || e.key === ' ') {
                    player.race = RACES[raceSelectIndex];
                    player.color = RACES[raceSelectIndex].color;
                    initGame();
                    state = GameState.PLAYING;
                    AudioSystem.sfx.levelComplete();
                    saveGameState();
                }
                return;
            }

            if (state === GameState.PLAYING) {
                if (e.key === 'Enter') {
                    if (destinationStar && selectedShips.length > 0) {
                        moveShips(selectedShips, destinationStar.id);
                    } else {
                        processTurn();
                    }
                    AudioSystem.sfx.select();
                } else if (e.key === 'Escape') {
                    if (destinationStar) {
                        destinationStar = null;
                    } else if (selectedShips.length > 0) {
                        selectedShips = [];
                    } else {
                        selectedStar = null;
                    }
                    updatePanels();
                }
            }
        });

        // ============================================
        // RENDER FUNCTIONS
        // ============================================
        function renderBackground() {
            ctx.fillStyle = CONFIG.COLORS.background;
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
            ctx.strokeStyle = CONFIG.COLORS.grid;
            ctx.lineWidth = 0.5;
            for (let x = 0; x < CONFIG.WIDTH; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CONFIG.HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y < CONFIG.HEIGHT; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CONFIG.WIDTH, y);
                ctx.stroke();
            }
            // Draw background stars with variety
            for (let i = 0; i < 150; i++) {
                const x = (i * 97 + 23) % CONFIG.WIDTH;
                const y = (i * 53 + 17) % CONFIG.HEIGHT;
                const brightness = 40 + (i * 7) % 60; // 40-100 brightness
                const starType = i % 5; // 0-4 for variety

                if (starType === 0) {
                    // Bright + shaped star
                    ctx.fillStyle = `rgb(${brightness + 50}, ${brightness + 50}, ${brightness + 80})`;
                    ctx.fillRect(x - 1, y, 3, 1);
                    ctx.fillRect(x, y - 1, 1, 3);
                } else if (starType === 1) {
                    // Larger dot
                    ctx.fillStyle = `rgb(${brightness + 30}, ${brightness + 20}, ${brightness})`;
                    ctx.fillRect(x, y, 2, 2);
                } else if (starType === 2) {
                    // Bright single pixel
                    ctx.fillStyle = `rgb(${brightness + 60}, ${brightness + 60}, ${brightness + 60})`;
                    ctx.fillRect(x, y, 1, 1);
                } else {
                    // Dim single pixel
                    ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness + 10})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }

        function getStarColor(star) {
            switch (star.starType) {
                case 'yellow': return CONFIG.COLORS.starYellow;
                case 'red': return CONFIG.COLORS.starRed;
                case 'blue': return CONFIG.COLORS.starBlue;
                case 'white': return CONFIG.COLORS.starWhite;
            }
            return CONFIG.COLORS.starYellow;
        }

        function renderStars() {
            // Draw travel lines for ships in transit
            ctx.strokeStyle = player.color;
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;
            for (const ship of ships) {
                if (ship.destination !== null && ship.owner === 'player') {
                    const origin = stars.find(s => s.id === ship.location);
                    const dest = stars.find(s => s.id === ship.destination);
                    if (origin && dest) {
                        ctx.beginPath();
                        ctx.moveTo(origin.x, origin.y);
                        ctx.lineTo(dest.x, dest.y);
                        ctx.stroke();
                    }
                }
            }
            ctx.setLineDash([]);

            // Draw destination preview line
            if (destinationStar && selectedStar && selectedShips.length > 0) {
                ctx.strokeStyle = CONFIG.COLORS.destination;
                ctx.setLineDash([3, 3]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(selectedStar.x, selectedStar.y);
                ctx.lineTo(destinationStar.x, destinationStar.y);
                ctx.stroke();
                ctx.setLineDash([]);

                // Travel time label
                const travelInfo = calculateTravelInfo(selectedStar, destinationStar, selectedShips);
                const midX = (selectedStar.x + destinationStar.x) / 2;
                const midY = (selectedStar.y + destinationStar.y) / 2;
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(midX - 35, midY - 10, 70, 20);
                ctx.fillStyle = CONFIG.COLORS.destination;
                ctx.font = '10px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(`${travelInfo.turns} turns`, midX, midY + 4);
            }

            for (const star of stars) {
                const isSelected = selectedStar && selectedStar.id === star.id;
                const isDestination = destinationStar && destinationStar.id === star.id;
                const isHovered = hoveredStar && hoveredStar.id === star.id;
                const shipsHere = getShipsAtStar(star.id).filter(s => s.owner === 'player');

                // Destination ring
                if (isDestination) {
                    ctx.strokeStyle = CONFIG.COLORS.destination;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, 24, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Selection ring
                if (isSelected) {
                    ctx.strokeStyle = player.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, 22, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Hover ring
                if (isHovered && !isSelected && !isDestination) {
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, 20, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Owner indicator ring
                if (star.owner === 'player') {
                    ctx.strokeStyle = player.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, 16, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Star glow
                if (star.explored) {
                    const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, 15);
                    gradient.addColorStop(0, getStarColor(star));
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Star core
                ctx.fillStyle = star.explored ? getStarColor(star) : CONFIG.COLORS.unexplored;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.explored ? 6 : 4, 0, Math.PI * 2);
                ctx.fill();

                // Star name
                ctx.fillStyle = star.explored ? '#fff' : '#666';
                ctx.font = '10px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(star.name, star.x, star.y + 28);

                // Ship count
                if (shipsHere.length > 0) {
                    ctx.fillStyle = player.color;
                    ctx.font = 'bold 10px Courier New';
                    ctx.fillText(`[${shipsHere.length}]`, star.x, star.y - 20);
                }

                // Planet type (when selected)
                if (star.explored && isSelected) {
                    const planetInfo = PLANET_TYPES[star.planetType];
                    ctx.fillStyle = planetInfo.color;
                    ctx.font = '9px Courier New';
                    ctx.fillText(planetInfo.name, star.x, star.y + 38);
                }
            }
        }

        function renderTitle() {
            renderBackground();
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('GALACTIC 4X', CONFIG.WIDTH / 2, 150);

            ctx.fillStyle = '#888';
            ctx.font = '16px Courier New';
            ctx.fillText('Explore, Expand, Exploit, Exterminate', CONFIG.WIDTH / 2, 190);

            if (hasSaveGame) {
                ctx.fillStyle = '#ffe66d';
                ctx.font = '16px Courier New';
                ctx.fillText('[ Continue ]', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 50);
                ctx.fillStyle = '#4ecdc4';
                ctx.fillText('[ New Game ]', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 90);
            } else {
                ctx.fillStyle = '#ffe66d';
                ctx.font = '14px Courier New';
                ctx.fillText('Click to begin', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 50);
            }

            ctx.fillStyle = '#666';
            ctx.font = '12px Courier New';
            ctx.fillText('Build your galactic empire across the stars', CONFIG.WIDTH / 2, CONFIG.HEIGHT - 100);
        }

        function renderRaceSelect() {
            renderBackground();
            ctx.fillStyle = 'rgba(0,0,0,0.85)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 28px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('SELECT YOUR RACE', CONFIG.WIDTH / 2, 80);

            const raceY = 120;
            const raceHeight = 50;

            for (let i = 0; i < RACES.length; i++) {
                const race = RACES[i];
                const y = raceY + i * raceHeight;
                const isHovered = i === raceSelectIndex;

                if (isHovered) {
                    ctx.fillStyle = 'rgba(78, 205, 196, 0.2)';
                    ctx.fillRect(100, y, CONFIG.WIDTH - 200, raceHeight - 5);
                }

                ctx.fillStyle = race.color;
                ctx.font = isHovered ? 'bold 16px Courier New' : '14px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText(race.name, 120, y + 20);

                ctx.fillStyle = '#888';
                ctx.font = '11px Courier New';
                ctx.fillText(race.desc, 120, y + 36);

                if (isHovered) {
                    ctx.fillStyle = race.color;
                    ctx.fillText('>', 105, y + 20);
                }
            }

            ctx.fillStyle = '#666';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('Use arrows or click to select, Enter to confirm', CONFIG.WIDTH / 2, CONFIG.HEIGHT - 40);
        }

        function renderPlaying() {
            renderBackground();
            renderStars();

            // Turn counter
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(CONFIG.WIDTH - 100, 10, 90, 30);
            ctx.strokeStyle = '#4a4a6a';
            ctx.strokeRect(CONFIG.WIDTH - 100, 10, 90, 30);
            ctx.fillStyle = '#ffe66d';
            ctx.font = 'bold 12px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('Turn ' + turn, CONFIG.WIDTH - 55, 30);
        }

        // ============================================
        // AUDIO CONTROLS
        // ============================================
        document.getElementById('musicToggle').addEventListener('change', (e) => {
            AudioSystem.musicEnabled = e.target.checked;
            gameData.musicEnabled = e.target.checked;
            saveGameData();
        });

        document.getElementById('sfxToggle').addEventListener('change', (e) => {
            AudioSystem.sfxEnabled = e.target.checked;
            gameData.sfxEnabled = e.target.checked;
            saveGameData();
        });

        AudioSystem.musicEnabled = gameData.musicEnabled;
        AudioSystem.sfxEnabled = gameData.sfxEnabled;
        document.getElementById('musicToggle').checked = gameData.musicEnabled;
        document.getElementById('sfxToggle').checked = gameData.sfxEnabled;

        // ============================================
        // GAME LOOP
        // ============================================
        let lastFrameTime = 0;

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            GameController.poll();

            switch (state) {
                case GameState.TITLE:
                    renderTitle();
                    break;
                case GameState.RACE_SELECT:
                    renderRaceSelect();
                    break;
                case GameState.PLAYING:
                case GameState.END_TURN:
                    renderPlaying();
                    break;
            }

            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // START
        // ============================================
        hasSaveGame = localStorage.getItem(SAVE_KEY) !== null;
        console.log('Galactic 4X initialized');
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
