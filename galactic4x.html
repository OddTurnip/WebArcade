<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic 4X</title>
    <link rel="icon" type="image/x-icon" href="https://oddturnip.com/favicon_turnip.ico">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #eee;
            padding: 10px;
        }
        h1 { margin-bottom: 10px; color: #4ecdc4; }
        #gameContainer {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }
        #leftColumn {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #gameCanvas {
            border: 4px solid #4a4a6a;
            border-radius: 4px;
            display: block;
            cursor: pointer;
        }
        #actionPanel {
            background: #1a1a2e;
            border: 4px solid #4a4a6a;
            border-radius: 4px;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #actionPanel.hidden { display: none; }
        #sidePanel {
            width: 300px;
            background: #1a1a2e;
            border: 4px solid #4a4a6a;
            border-radius: 4px;
            padding: 15px;
            min-height: 480px;
            max-height: 550px;
            overflow-y: auto;
        }
        .panel-title {
            color: #4ecdc4;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            border-bottom: 1px solid #4a4a6a;
            padding-bottom: 5px;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 11px;
        }
        .info-label { color: #888; }
        .info-value { color: #ffe66d; }
        .slider-container {
            margin: 8px 0;
            padding: 8px;
            background: #252540;
            border-radius: 4px;
        }
        .slider-container.locked-auto {
            background: #1a1a25;
            opacity: 0.6;
        }
        .slider-container.locked-noship {
            background: #2a2520;
            border: 1px solid #665500;
        }
        .slider-container.locked-user {
            background: #2a2a35;
            border: 1px solid #888;
        }
        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .slider-label {
            font-size: 11px;
            color: #888;
        }
        .slider-value {
            color: #4ecdc4;
            font-size: 11px;
            font-weight: bold;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .lock-btn {
            background: none;
            border: 1px solid #666;
            color: #666;
            width: 20px;
            height: 20px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 3px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .lock-btn:hover { border-color: #888; color: #888; }
        .lock-btn.locked { border-color: #aaa; color: #aaa; background: #3a3a4a; }
        .lock-btn:disabled { cursor: not-allowed; opacity: 0.5; }
        .slider-production {
            font-size: 10px;
            color: #4a9;
            margin-top: 4px;
        }
        .lock-reason {
            font-size: 9px;
            color: #888;
            font-style: italic;
            margin-top: 2px;
        }
        .lock-reason.warning {
            color: #cc8800;
        }
        input[type="range"] {
            flex: 1;
            height: 16px;
            -webkit-appearance: none;
            background: #2a2a4a;
            border-radius: 4px;
            cursor: pointer;
        }
        input[type="range"]:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #4ecdc4;
            border-radius: 2px;
            cursor: pointer;
        }
        input[type="range"]:disabled::-webkit-slider-thumb {
            background: #666;
        }
        .btn {
            background: #2a2a4a;
            border: 2px solid #4ecdc4;
            color: #4ecdc4;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            margin: 5px 2px;
            transition: all 0.2s;
        }
        .btn:hover {
            background: #4ecdc4;
            color: #1a1a2e;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background: #4ecdc4;
            color: #1a1a2e;
            font-weight: bold;
        }
        .btn-primary:hover {
            background: #6fefe6;
        }
        .btn-danger {
            border-color: #ff6b6b;
            color: #ff6b6b;
        }
        .btn-danger:hover {
            background: #ff6b6b;
            color: #1a1a2e;
        }
        .ship-list {
            max-height: 80px;
            overflow-y: auto;
            border: 1px solid #4a4a6a;
            padding: 5px;
            margin: 5px 0;
            font-size: 11px;
        }
        .ship-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 0;
            border-bottom: 1px solid #2a2a4a;
        }
        .ship-item:last-child { border-bottom: none; }
        .build-options {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }
        .build-btn {
            flex: 1;
            min-width: 70px;
            padding: 5px;
            font-size: 10px;
        }
        #controls {
            margin-top: 15px;
            font-size: 11px;
            color: #888;
            text-align: center;
            max-width: 950px;
            line-height: 1.6;
        }
        #audioControls {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        #audioControls label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #audioControls input[type="checkbox"] {
            cursor: pointer;
            accent-color: #4ecdc4;
        }
        #aboutSection {
            margin-top: 15px;
            max-width: 700px;
            background: #1a1a2e;
            border: 2px solid #4a4a6a;
            border-radius: 4px;
            padding: 15px;
        }
        #aboutSection h3 {
            color: #4ecdc4;
            font-size: 14px;
            margin-bottom: 10px;
        }
        #aboutSection p {
            font-size: 11px;
            color: #aaa;
            line-height: 1.5;
            margin-bottom: 8px;
        }
        #aboutSection strong {
            color: #ffe66d;
        }
        .travel-info {
            background: #252540;
            border: 1px solid #4a4a6a;
            border-radius: 4px;
            padding: 8px;
            margin: 10px 0;
            font-size: 11px;
        }
        .travel-info .distance { color: #4a9fff; }
        .travel-info .turns { color: #ffe66d; }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <h1>Galactic 4X</h1>
    <div id="gameContainer">
        <div id="leftColumn">
            <canvas id="gameCanvas" width="640" height="480"></canvas>
            <div id="actionPanel" class="hidden">
                <button class="btn btn-primary" id="endTurnBtn" onclick="window.endTurn()">End Turn</button>
                <span id="turnInfo" style="color:#888;font-size:12px;"></span>
            </div>
        </div>
        <div id="sidePanel" class="hidden">
            <div id="panelContent"></div>
        </div>
    </div>
    <div id="controls">
        <strong>Mouse:</strong> Click stars to select | Click destination to move ships | Drag sliders to adjust production<br>
        <strong>Keyboard:</strong> Enter = End Turn | Escape = Deselect
    </div>
    <div id="audioControls">
        <label><input type="checkbox" id="musicToggle" checked> Music</label>
        <label><input type="checkbox" id="sfxToggle" checked> Sound Effects</label>
    </div>
    <div id="aboutSection">
        <h3>How to Play</h3>
        <p><strong>Industry</strong> represents your colony's manufacturing capacity (0-100%). Higher industry means more production output per turn. Allocate production to "Industry Growth" to build up your capacity.</p>
        <p><strong>Population</strong> is your workforce. More population = more base production. Population grows based on your "Ecology/Growth" slider allocation and planet type. Each planet has a maximum population based on its type (Terran=100, Ocean=90, etc).</p>
        <p><strong>Production Formula:</strong> Base Production = Population x (Industry/100) x Planet Modifier. This base is then split according to your sliders.</p>
        <p><strong>Slider Locks:</strong> Click the lock icon to prevent a slider from changing when you adjust others. Some sliders auto-lock when maxed out or not applicable.</p>
    </div>

    <script src="controller.js"></script>
    <script src="audio.js"></script>
    <script src="storage.js"></script>
    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            WIDTH: 640,
            HEIGHT: 480,
            STAR_COUNT: 24,
            MIN_STAR_DISTANCE: 60,
            PARSEC_SCALE: 10, // pixels per light year
            COLORS: {
                background: '#0a0a1a',
                grid: '#1a1a2e',
                starYellow: '#ffe66d',
                starRed: '#ff6b6b',
                starBlue: '#4a9fff',
                starWhite: '#ffffff',
                text: '#ffffff',
                textHighlight: '#ffe66d',
                playerHighlight: '#4ecdc4',
                unexplored: '#666666'
            }
        };

        // Planet types with production modifiers
        const PLANET_TYPES = {
            terran: { name: 'Terran', maxPop: 100, industryMod: 1.0, ecoMod: 1.0, color: '#4ecdc4' },
            ocean: { name: 'Ocean', maxPop: 90, industryMod: 0.9, ecoMod: 1.1, color: '#4a9fff' },
            jungle: { name: 'Jungle', maxPop: 80, industryMod: 0.85, ecoMod: 1.2, color: '#2e8b57' },
            arid: { name: 'Arid', maxPop: 60, industryMod: 0.8, ecoMod: 0.7, color: '#daa520' },
            desert: { name: 'Desert', maxPop: 50, industryMod: 0.7, ecoMod: 0.6, color: '#c2b280' },
            tundra: { name: 'Tundra', maxPop: 40, industryMod: 0.6, ecoMod: 0.5, color: '#b0e0e6' },
            barren: { name: 'Barren', maxPop: 30, industryMod: 0.5, ecoMod: 0.3, color: '#808080' },
            inferno: { name: 'Inferno', maxPop: 20, industryMod: 0.4, ecoMod: 0.2, color: '#ff4500' },
            toxic: { name: 'Toxic', maxPop: 15, industryMod: 0.3, ecoMod: 0.1, color: '#7cfc00' }
        };

        // Ship types (preset, no customization)
        const SHIP_TYPES = {
            scout: { name: 'Scout', cost: 30, speed: 3, attack: 1, defense: 1, icon: 'S' },
            fighter: { name: 'Fighter', cost: 60, speed: 2, attack: 4, defense: 2, icon: 'F' },
            destroyer: { name: 'Destroyer', cost: 120, speed: 2, attack: 8, defense: 6, icon: 'D' },
            colony: { name: 'Colony Ship', cost: 200, speed: 1, attack: 0, defense: 1, icon: 'C', colonize: true }
        };

        // Alien races (no mechanical differences yet)
        const RACES = [
            { id: 'terran', name: 'Terran Federation', color: '#4ecdc4', desc: 'Adaptable and expansionist humans' },
            { id: 'crystalline', name: 'Crystalline Collective', color: '#9932cc', desc: 'Silicon-based mineral lifeforms' },
            { id: 'aquan', name: 'Aquan Dominion', color: '#4a9fff', desc: 'Ocean-dwelling telepaths' },
            { id: 'hivemind', name: 'Hive Swarm', color: '#ffa500', desc: 'Unified insectoid consciousness' },
            { id: 'aviari', name: 'Aviari Consortium', color: '#ffe66d', desc: 'Elegant avian traders' },
            { id: 'saurian', name: 'Saurian Empire', color: '#ff6b6b', desc: 'Ancient reptilian warriors' }
        ];

        // Star names
        const STAR_NAMES = [
            'Sol', 'Alpha', 'Proxima', 'Vega', 'Sirius', 'Rigel', 'Deneb', 'Altair',
            'Polaris', 'Arcturus', 'Capella', 'Betelgeuse', 'Aldebaran', 'Antares',
            'Spica', 'Procyon', 'Canopus', 'Achernar', 'Hadar', 'Acrux', 'Mimosa',
            'Regulus', 'Adhara', 'Shaula', 'Castor', 'Bellatrix', 'Elnath', 'Miaplacidus',
            'Alnilam', 'Alnitak', 'Alioth', 'Dubhe', 'Mirfak', 'Wezen', 'Kaus', 'Sargas'
        ];

        // ============================================
        // PERSISTENCE
        // ============================================
        const GAME_ID = 'galactic4x';
        const SAVE_KEY = 'galactic4x_save';

        let gameData = GameStorage.load(GAME_ID, {
            ...GameStorage.defaults.arcade(),
            gamesWon: 0
        });

        function saveGameData() {
            GameStorage.save(GAME_ID, gameData);
        }

        function saveGameState() {
            if (state !== GameState.PLAYING) return;

            const saveData = {
                turn,
                player: { race: player.race, color: player.color },
                stars: stars.map(s => ({
                    id: s.id, name: s.name, x: s.x, y: s.y,
                    starType: s.starType, planetType: s.planetType,
                    owner: s.owner, explored: s.explored,
                    population: s.population, industry: s.industry, defense: s.defense,
                    sliders: {...s.sliders}, lockedSliders: [...(s.lockedSliders || [])],
                    shipProgress: s.shipProgress, buildingShip: s.buildingShip
                })),
                ships: ships.map(s => ({
                    id: s.id, type: s.type, owner: s.owner,
                    location: s.location, destination: s.destination,
                    turnsToArrival: s.turnsToArrival
                })),
                nextShipId
            };

            try {
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
            } catch (e) {
                console.warn('Failed to save game:', e);
            }
        }

        function loadGameState() {
            try {
                const saved = localStorage.getItem(SAVE_KEY);
                if (!saved) return false;

                const data = JSON.parse(saved);

                turn = data.turn;
                player.race = data.player.race;
                player.color = data.player.color;
                stars = data.stars.map(s => ({
                    ...s,
                    lockedSliders: s.lockedSliders || []
                }));
                ships = data.ships;
                nextShipId = data.nextShipId;

                return true;
            } catch (e) {
                console.warn('Failed to load game:', e);
                return false;
            }
        }

        function clearSaveGame() {
            localStorage.removeItem(SAVE_KEY);
        }

        // ============================================
        // GAME STATE
        // ============================================
        const GameState = {
            TITLE: 'title',
            RACE_SELECT: 'race_select',
            PLAYING: 'playing',
            END_TURN: 'end_turn'
        };

        let state = GameState.TITLE;
        let turn = 1;

        // Player state
        let player = {
            race: null,
            color: '#4ecdc4'
        };

        // Galaxy state
        let stars = [];
        let ships = [];
        let nextShipId = 1;

        // UI state
        let selectedStar = null;
        let selectedShips = [];
        let movingFleet = false;
        let hoveredStar = null;
        let raceSelectIndex = 0;
        let hasSaveGame = false;

        // Side panel reference
        const sidePanel = document.getElementById('sidePanel');
        const panelContent = document.getElementById('panelContent');
        const actionPanel = document.getElementById('actionPanel');
        const turnInfo = document.getElementById('turnInfo');

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ============================================
        // GALAXY GENERATION
        // ============================================
        function generateGalaxy() {
            stars = [];
            ships = [];
            nextShipId = 1;
            const shuffledNames = [...STAR_NAMES].sort(() => Math.random() - 0.5);

            // Generate stars with minimum distance
            for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
                let attempts = 0;
                let x, y, valid;

                do {
                    x = 50 + Math.random() * (CONFIG.WIDTH - 100);
                    y = 50 + Math.random() * (CONFIG.HEIGHT - 100);
                    valid = true;

                    for (const star of stars) {
                        const dist = Math.sqrt((x - star.x) ** 2 + (y - star.y) ** 2);
                        if (dist < CONFIG.MIN_STAR_DISTANCE) {
                            valid = false;
                            break;
                        }
                    }
                    attempts++;
                } while (!valid && attempts < 100);

                if (!valid) continue;

                const starTypes = ['yellow', 'red', 'blue', 'white'];
                const starType = starTypes[Math.floor(Math.random() * starTypes.length)];

                // Weight planet types (better planets less common)
                let planetType;
                const roll = Math.random();
                if (roll < 0.1) planetType = 'terran';
                else if (roll < 0.2) planetType = 'ocean';
                else if (roll < 0.35) planetType = 'jungle';
                else if (roll < 0.5) planetType = 'arid';
                else if (roll < 0.65) planetType = 'desert';
                else if (roll < 0.75) planetType = 'tundra';
                else if (roll < 0.85) planetType = 'barren';
                else if (roll < 0.93) planetType = 'inferno';
                else planetType = 'toxic';

                stars.push({
                    id: i,
                    name: shuffledNames[i] || `Star-${i}`,
                    x: x,
                    y: y,
                    starType: starType,
                    planetType: planetType,
                    owner: null,
                    explored: false,
                    // Colony data (populated when colonized)
                    population: 0,
                    industry: 0,
                    defense: 0,
                    // Production sliders (%)
                    sliders: { ship: 25, def: 0, ind: 50, eco: 25 },
                    lockedSliders: [], // User-locked sliders
                    // Ship building
                    shipProgress: 0,
                    buildingShip: null
                });
            }

            // Give player a starting system (find a good one)
            let homeStar = stars.find(s => s.planetType === 'terran') ||
                           stars.find(s => s.planetType === 'ocean') ||
                           stars[0];

            homeStar.owner = 'player';
            homeStar.explored = true;
            homeStar.population = 40;
            homeStar.industry = 20;
            homeStar.defense = 5;
            homeStar.planetType = 'terran'; // Home world is always terran

            // Give player starting ships
            ships.push({
                id: nextShipId++,
                type: 'scout',
                owner: 'player',
                location: homeStar.id,
                destination: null,
                turnsToArrival: 0
            });
            ships.push({
                id: nextShipId++,
                type: 'scout',
                owner: 'player',
                location: homeStar.id,
                destination: null,
                turnsToArrival: 0
            });
            ships.push({
                id: nextShipId++,
                type: 'colony',
                owner: 'player',
                location: homeStar.id,
                destination: null,
                turnsToArrival: 0
            });

            // Only home star is explored initially - no nearby stars auto-explored
        }

        // ============================================
        // GAME LOGIC
        // ============================================
        function initGame() {
            turn = 1;
            selectedStar = null;
            selectedShips = [];
            movingFleet = false;
            generateGalaxy();
            actionPanel.classList.remove('hidden');
            updateTurnInfo();
        }

        function updateTurnInfo() {
            const colonies = getPlayerColonies();
            const totalShips = ships.filter(s => s.owner === 'player').length;
            turnInfo.textContent = `Turn ${turn} | Colonies: ${colonies.length} | Ships: ${totalShips}`;
        }

        function getShipsAtStar(starId) {
            return ships.filter(s => s.location === starId && s.destination === null);
        }

        function getShipsInTransit() {
            return ships.filter(s => s.destination !== null);
        }

        function getPlayerColonies() {
            return stars.filter(s => s.owner === 'player');
        }

        function calculateProduction(star) {
            if (star.owner !== 'player') return null;

            const planetInfo = PLANET_TYPES[star.planetType];
            const baseProduction = star.population * (star.industry / 100) * planetInfo.industryMod;

            return {
                ship: Math.floor(baseProduction * (star.sliders.ship / 100)),
                def: Math.floor(baseProduction * (star.sliders.def / 100)),
                ind: Math.floor(baseProduction * (star.sliders.ind / 100) * 0.5),
                eco: Math.floor(baseProduction * (star.sliders.eco / 100) * planetInfo.ecoMod * 0.3)
            };
        }

        function getSliderLockState(star, sliderKey) {
            // Check user lock first
            if (star.lockedSliders && star.lockedSliders.includes(sliderKey)) {
                return { locked: true, type: 'user', reason: 'Locked by you' };
            }

            const planetInfo = PLANET_TYPES[star.planetType];

            // Auto-lock conditions
            if (sliderKey === 'ind' && star.industry >= 100) {
                return { locked: true, type: 'auto', reason: 'Industry maxed' };
            }
            if (sliderKey === 'eco' && star.population >= planetInfo.maxPop) {
                return { locked: true, type: 'auto', reason: 'Population maxed' };
            }
            if (sliderKey === 'ship' && !star.buildingShip) {
                return { locked: true, type: 'noship', reason: 'No ship queued' };
            }

            return { locked: false, type: null, reason: null };
        }

        function normalizeSliders(star, changedKey, newValue) {
            const lockStates = {};
            for (const key of Object.keys(star.sliders)) {
                lockStates[key] = getSliderLockState(star, key);
            }

            // Set the changed slider
            star.sliders[changedKey] = newValue;

            // Get unlocked sliders (excluding the one we just changed)
            const unlockedKeys = Object.keys(star.sliders).filter(k =>
                k !== changedKey && !lockStates[k].locked
            );

            // Calculate how much we need to adjust
            const total = Object.values(star.sliders).reduce((a, b) => a + b, 0);
            const diff = total - 100;

            if (diff === 0 || unlockedKeys.length === 0) return;

            // Distribute the difference among unlocked sliders
            const unlockedTotal = unlockedKeys.reduce((sum, k) => sum + star.sliders[k], 0);

            if (unlockedTotal === 0) {
                // All unlocked are 0, just reduce equally
                const perSlider = Math.floor(diff / unlockedKeys.length);
                for (const key of unlockedKeys) {
                    star.sliders[key] = Math.max(0, -perSlider);
                }
            } else {
                // Distribute proportionally
                for (const key of unlockedKeys) {
                    const proportion = star.sliders[key] / unlockedTotal;
                    star.sliders[key] = Math.max(0, Math.round(star.sliders[key] - diff * proportion));
                }
            }

            // Final normalization pass
            const finalTotal = Object.values(star.sliders).reduce((a, b) => a + b, 0);
            if (finalTotal !== 100 && unlockedKeys.length > 0) {
                const adjustment = 100 - finalTotal;
                for (const key of unlockedKeys) {
                    if (star.sliders[key] > 0 || adjustment > 0) {
                        star.sliders[key] = Math.max(0, star.sliders[key] + adjustment);
                        break;
                    }
                }
            }
        }

        function processTurn() {
            state = GameState.END_TURN;

            // Process each colony
            for (const star of getPlayerColonies()) {
                const production = calculateProduction(star);
                const planetInfo = PLANET_TYPES[star.planetType];

                // Industry growth
                star.industry = Math.min(100, star.industry + production.ind);

                // Population growth
                const maxPop = planetInfo.maxPop;
                if (star.population < maxPop) {
                    star.population = Math.min(maxPop, star.population + production.eco);
                }

                // Defense growth
                star.defense += production.def;

                // Ship production
                if (star.buildingShip) {
                    star.shipProgress += production.ship;
                    const shipType = SHIP_TYPES[star.buildingShip];

                    if (star.shipProgress >= shipType.cost) {
                        // Ship completed!
                        ships.push({
                            id: nextShipId++,
                            type: star.buildingShip,
                            owner: 'player',
                            location: star.id,
                            destination: null,
                            turnsToArrival: 0
                        });
                        star.shipProgress = 0;
                        star.buildingShip = null;
                        AudioSystem.sfx.powerUp();
                    }
                }
            }

            // Process ship movement
            for (const ship of ships) {
                if (ship.destination !== null) {
                    ship.turnsToArrival--;

                    if (ship.turnsToArrival <= 0) {
                        // Ship arrived
                        ship.location = ship.destination;
                        ship.destination = null;

                        // Explore the star
                        const star = stars.find(s => s.id === ship.location);
                        if (star && !star.explored) {
                            star.explored = true;
                            AudioSystem.sfx.select();
                        }
                    }
                }
            }

            turn++;
            state = GameState.PLAYING;
            updateSidePanel();
            updateTurnInfo();
            saveGameState();
        }

        function calculateTravelInfo(originStar, destStar, shipIds) {
            const dist = Math.sqrt((destStar.x - originStar.x) ** 2 + (destStar.y - originStar.y) ** 2);
            const lightYears = Math.round(dist / CONFIG.PARSEC_SCALE * 10) / 10;

            // Find slowest ship in selection
            let slowestSpeed = Infinity;
            let slowestShipName = '';

            for (const shipId of shipIds) {
                const ship = ships.find(s => s.id === shipId);
                if (ship) {
                    const shipType = SHIP_TYPES[ship.type];
                    if (shipType.speed < slowestSpeed) {
                        slowestSpeed = shipType.speed;
                        slowestShipName = shipType.name;
                    }
                }
            }

            const turns = Math.max(1, Math.ceil(dist / (50 * slowestSpeed)));

            return {
                lightYears,
                turns,
                slowestShipName,
                slowestSpeed
            };
        }

        function moveShips(shipIds, destinationId) {
            const destStar = stars.find(s => s.id === destinationId);
            if (!destStar) return;

            for (const shipId of shipIds) {
                const ship = ships.find(s => s.id === shipId);
                if (!ship || ship.destination !== null) continue;

                const originStar = stars.find(s => s.id === ship.location);
                const shipType = SHIP_TYPES[ship.type];

                // Calculate distance and travel time
                const dist = Math.sqrt((destStar.x - originStar.x) ** 2 + (destStar.y - originStar.y) ** 2);
                const turns = Math.ceil(dist / (50 * shipType.speed));

                ship.destination = destinationId;
                ship.turnsToArrival = Math.max(1, turns);
            }

            AudioSystem.sfx.select();
            movingFleet = false;
            selectedShips = [];
            updateSidePanel();
            saveGameState();
        }

        function colonizeStar(shipId, starId) {
            const ship = ships.find(s => s.id === shipId);
            const star = stars.find(s => s.id === starId);

            if (!ship || !star || ship.type !== 'colony' || star.owner !== null) return false;

            const planetInfo = PLANET_TYPES[star.planetType];
            if (planetInfo.maxPop === 0) return false; // Can't colonize dead worlds

            // Remove colony ship
            ships = ships.filter(s => s.id !== shipId);

            // Establish colony
            star.owner = 'player';
            star.explored = true;
            star.population = 10;
            star.industry = 5;
            star.defense = 0;
            star.lockedSliders = [];

            AudioSystem.sfx.levelComplete();
            updateSidePanel();
            updateTurnInfo();
            saveGameState();
            return true;
        }

        function startBuildingShip(starId, shipType) {
            const star = stars.find(s => s.id === starId);
            if (!star || star.owner !== 'player') return;

            star.buildingShip = shipType;
            star.shipProgress = 0;
            AudioSystem.sfx.select();
            updateSidePanel();
            saveGameState();
        }

        function cancelBuildingShip(starId) {
            const star = stars.find(s => s.id === starId);
            if (!star) return;

            star.buildingShip = null;
            star.shipProgress = 0;
            updateSidePanel();
            saveGameState();
        }

        // ============================================
        // UI UPDATES
        // ============================================
        function updateSidePanel() {
            if (!selectedStar) {
                sidePanel.classList.add('hidden');
                return;
            }

            sidePanel.classList.remove('hidden');
            const star = selectedStar;
            const shipsHere = getShipsAtStar(star.id);
            const playerShips = shipsHere.filter(s => s.owner === 'player');

            let html = '';

            // Star info
            html += `<div class="panel-title">${star.name}</div>`;

            if (star.explored) {
                const planetInfo = PLANET_TYPES[star.planetType];
                html += `<div class="info-row"><span class="info-label">Planet Type:</span><span class="info-value" style="color:${planetInfo.color}">${planetInfo.name}</span></div>`;
                html += `<div class="info-row"><span class="info-label">Max Population:</span><span class="info-value">${planetInfo.maxPop}</span></div>`;
            } else {
                html += `<div class="info-row"><span class="info-label">Planet Type:</span><span class="info-value" style="color:#666">Unknown</span></div>`;
                html += `<div class="info-row"><span class="info-label">Max Population:</span><span class="info-value" style="color:#666">???</span></div>`;
            }

            if (star.owner === 'player') {
                const planetInfo = PLANET_TYPES[star.planetType];

                // Colony info
                html += `<div style="margin-top:12px" class="panel-title">Colony Status</div>`;
                html += `<div class="info-row"><span class="info-label">Population:</span><span class="info-value">${star.population} / ${planetInfo.maxPop}</span></div>`;
                html += `<div class="info-row"><span class="info-label">Industry:</span><span class="info-value">${star.industry}%</span></div>`;
                html += `<div class="info-row"><span class="info-label">Defense:</span><span class="info-value">${star.defense}</span></div>`;

                // Production sliders with per-turn info
                const prod = calculateProduction(star);
                html += `<div style="margin-top:12px" class="panel-title">Production Allocation</div>`;

                const sliderTypes = [
                    { key: 'ship', label: 'Ship Production', prodKey: 'ship', prodLabel: 'production' },
                    { key: 'def', label: 'Defense', prodKey: 'def', prodLabel: 'defense' },
                    { key: 'ind', label: 'Industry Growth', prodKey: 'ind', prodLabel: '% industry' },
                    { key: 'eco', label: 'Ecology/Growth', prodKey: 'eco', prodLabel: 'population' }
                ];

                for (const slider of sliderTypes) {
                    const lockState = getSliderLockState(star, slider.key);
                    let containerClass = 'slider-container';
                    if (lockState.locked) {
                        if (lockState.type === 'auto') containerClass += ' locked-auto';
                        else if (lockState.type === 'noship') containerClass += ' locked-noship';
                        else if (lockState.type === 'user') containerClass += ' locked-user';
                    }

                    const isUserLocked = star.lockedSliders && star.lockedSliders.includes(slider.key);
                    const lockBtnClass = isUserLocked ? 'lock-btn locked' : 'lock-btn';
                    const lockDisabled = lockState.type === 'auto' || lockState.type === 'noship';

                    html += `<div class="${containerClass}">
                        <div class="slider-header">
                            <span class="slider-label">${slider.label}</span>
                            <span class="slider-value">${star.sliders[slider.key]}%</span>
                        </div>
                        <div class="slider-row">
                            <input type="range" min="0" max="100" step="5" value="${star.sliders[slider.key]}"
                                   ${lockState.locked ? 'disabled' : ''}
                                   onchange="adjustSlider(${star.id}, '${slider.key}', this.value)">
                            <button class="${lockBtnClass}" ${lockDisabled ? 'disabled' : ''}
                                    onclick="toggleSliderLock(${star.id}, '${slider.key}')"
                                    title="${isUserLocked ? 'Unlock' : 'Lock'}">
                                ${isUserLocked ? 'ðŸ”’' : 'ðŸ”“'}
                            </button>
                        </div>
                        <div class="slider-production">+${prod[slider.prodKey]} ${slider.prodLabel}/turn</div>`;

                    if (lockState.locked && lockState.reason) {
                        const reasonClass = lockState.type === 'noship' ? 'lock-reason warning' : 'lock-reason';
                        const prefix = lockState.type === 'noship' ? 'âš  ' : '';
                        html += `<div class="${reasonClass}">${prefix}${lockState.reason}</div>`;
                    }

                    html += `</div>`;
                }

                // Ship building
                html += `<div style="margin-top:12px" class="panel-title">Shipyard</div>`;

                if (star.buildingShip) {
                    const shipType = SHIP_TYPES[star.buildingShip];
                    const progress = Math.floor((star.shipProgress / shipType.cost) * 100);
                    const remaining = shipType.cost - star.shipProgress;
                    const turnsLeft = prod.ship > 0 ? Math.ceil(remaining / prod.ship) : 'âˆž';

                    html += `<div class="info-row"><span class="info-label">Building:</span><span class="info-value">${shipType.name}</span></div>`;
                    html += `<div class="info-row"><span class="info-label">Progress:</span><span class="info-value">${progress}% (${star.shipProgress}/${shipType.cost})</span></div>`;
                    html += `<div class="info-row"><span class="info-label">ETA:</span><span class="info-value">${turnsLeft} turns</span></div>`;
                    html += `<button class="btn btn-danger" onclick="cancelBuildingShip(${star.id})">Cancel Build</button>`;
                } else {
                    html += `<div class="build-options">`;
                    for (const [key, type] of Object.entries(SHIP_TYPES)) {
                        html += `<button class="btn build-btn" onclick="startBuildingShip(${star.id}, '${key}')">${type.name}<br><span style="font-size:9px">(${type.cost})</span></button>`;
                    }
                    html += `</div>`;
                }
            } else if (star.explored) {
                const planetInfo = PLANET_TYPES[star.planetType];
                html += `<div style="margin-top:12px;color:#888;font-size:11px">Unclaimed system</div>`;

                // Check if player has colony ship here
                const colonyShip = playerShips.find(s => s.type === 'colony');
                if (colonyShip && planetInfo.maxPop > 0) {
                    html += `<button class="btn" style="margin-top:10px" onclick="colonizeStar(${colonyShip.id}, ${star.id})">Colonize Planet</button>`;
                } else if (planetInfo.maxPop === 0) {
                    html += `<div style="color:#ff6b6b;font-size:11px;margin-top:5px">Planet cannot be colonized</div>`;
                }
            } else {
                html += `<div style="margin-top:12px;color:#888;font-size:11px">Unexplored - send a ship to scout</div>`;
            }

            // Ships at this location
            if (playerShips.length > 0) {
                html += `<div style="margin-top:12px" class="panel-title">Ships Here</div>`;
                html += `<div class="ship-list">`;
                for (const ship of playerShips) {
                    const shipType = SHIP_TYPES[ship.type];
                    const selected = selectedShips.includes(ship.id);
                    html += `<div class="ship-item" style="${selected ? 'background:#2a4a4a' : ''}">
                        <span>${shipType.name} <span style="color:#666">(spd ${shipType.speed})</span></span>
                        <button class="btn" style="padding:2px 6px;font-size:9px" onclick="toggleShipSelection(${ship.id})">${selected ? 'âœ“' : 'Sel'}</button>
                    </div>`;
                }
                html += `</div>`;

                if (selectedShips.length > 0) {
                    if (movingFleet) {
                        // Show travel info for hovered star
                        if (hoveredStar && hoveredStar !== selectedStar) {
                            const travelInfo = calculateTravelInfo(selectedStar, hoveredStar, selectedShips);
                            html += `<div class="travel-info">
                                <div>Distance: <span class="distance">${travelInfo.lightYears} LY</span></div>
                                <div>Travel time: <span class="turns">${travelInfo.turns} turns</span></div>
                                ${selectedShips.length > 1 ? `<div style="color:#888;font-size:10px">Slowest: ${travelInfo.slowestShipName} (speed ${travelInfo.slowestSpeed})</div>` : ''}
                            </div>`;
                        } else {
                            html += `<div style="color:#ffe66d;font-size:11px;margin-top:8px">Click a destination star...</div>`;
                        }
                        html += `<button class="btn btn-danger" onclick="cancelMove()">Cancel Move</button>`;
                    } else {
                        html += `<button class="btn" onclick="startMove()">Move ${selectedShips.length} Ship${selectedShips.length > 1 ? 's' : ''}</button>`;
                    }
                }
            }

            // Ships in transit to this star
            const incomingShips = ships.filter(s => s.destination === star.id && s.owner === 'player');
            if (incomingShips.length > 0) {
                html += `<div style="margin-top:10px" class="panel-title">Incoming Ships</div>`;
                html += `<div class="ship-list">`;
                for (const ship of incomingShips) {
                    const shipType = SHIP_TYPES[ship.type];
                    html += `<div class="ship-item"><span>${shipType.name}</span><span>${ship.turnsToArrival} turns</span></div>`;
                }
                html += `</div>`;
            }

            panelContent.innerHTML = html;
        }

        // Global functions for UI callbacks
        window.adjustSlider = function(starId, sliderKey, value) {
            const star = stars.find(s => s.id === starId);
            if (!star) return;

            value = parseInt(value);
            normalizeSliders(star, sliderKey, value);
            updateSidePanel();
            saveGameState();
        };

        window.toggleSliderLock = function(starId, sliderKey) {
            const star = stars.find(s => s.id === starId);
            if (!star) return;

            if (!star.lockedSliders) star.lockedSliders = [];

            const idx = star.lockedSliders.indexOf(sliderKey);
            if (idx >= 0) {
                star.lockedSliders.splice(idx, 1);
            } else {
                star.lockedSliders.push(sliderKey);
            }

            updateSidePanel();
            saveGameState();
        };

        window.toggleShipSelection = function(shipId) {
            const idx = selectedShips.indexOf(shipId);
            if (idx >= 0) {
                selectedShips.splice(idx, 1);
            } else {
                selectedShips.push(shipId);
            }
            updateSidePanel();
        };

        window.startMove = function() {
            movingFleet = true;
            updateSidePanel();
        };

        window.cancelMove = function() {
            movingFleet = false;
            updateSidePanel();
        };

        window.endTurn = function() {
            processTurn();
            AudioSystem.sfx.select();
        };

        window.startBuildingShip = startBuildingShip;
        window.cancelBuildingShip = cancelBuildingShip;
        window.colonizeStar = colonizeStar;

        // ============================================
        // INPUT HANDLING
        // ============================================
        function getStarAtPosition(x, y) {
            for (const star of stars) {
                const dist = Math.sqrt((x - star.x) ** 2 + (y - star.y) ** 2);
                if (dist < 20) {
                    return star;
                }
            }
            return null;
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            AudioSystem.unlock();

            if (state === GameState.TITLE) {
                // Check for continue button
                if (hasSaveGame && y >= CONFIG.HEIGHT / 2 + 30 && y <= CONFIG.HEIGHT / 2 + 60) {
                    if (loadGameState()) {
                        state = GameState.PLAYING;
                        actionPanel.classList.remove('hidden');
                        updateTurnInfo();
                        AudioSystem.sfx.select();
                        return;
                    }
                }
                // Check for new game button
                if (y >= CONFIG.HEIGHT / 2 + 70 && y <= CONFIG.HEIGHT / 2 + 100) {
                    clearSaveGame();
                    state = GameState.RACE_SELECT;
                    AudioSystem.sfx.select();
                    return;
                }
                // Default: if no save, go to race select
                if (!hasSaveGame) {
                    state = GameState.RACE_SELECT;
                    AudioSystem.sfx.select();
                }
                return;
            }

            if (state === GameState.RACE_SELECT) {
                // Check if clicked on a race
                const raceY = 120;
                const raceHeight = 50;
                for (let i = 0; i < RACES.length; i++) {
                    const ry = raceY + i * raceHeight;
                    if (y >= ry && y < ry + raceHeight && x >= 100 && x <= CONFIG.WIDTH - 100) {
                        player.race = RACES[i];
                        player.color = RACES[i].color;
                        initGame();
                        state = GameState.PLAYING;
                        AudioSystem.sfx.levelComplete();
                        saveGameState();
                        return;
                    }
                }
                return;
            }

            if (state === GameState.PLAYING) {
                const clickedStar = getStarAtPosition(x, y);

                if (movingFleet && clickedStar && clickedStar !== selectedStar) {
                    // Move ships to clicked star
                    moveShips(selectedShips, clickedStar.id);
                    return;
                }

                if (clickedStar) {
                    selectedStar = clickedStar;
                    selectedShips = [];
                    movingFleet = false;
                    AudioSystem.sfx.select();
                    updateSidePanel();
                } else {
                    selectedStar = null;
                    selectedShips = [];
                    movingFleet = false;
                    updateSidePanel();
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (state === GameState.PLAYING) {
                const prevHovered = hoveredStar;
                hoveredStar = getStarAtPosition(x, y);

                // Update panel if hovering during move to show travel info
                if (movingFleet && hoveredStar !== prevHovered) {
                    updateSidePanel();
                }
            }
        });

        document.addEventListener('keydown', (e) => {
            AudioSystem.unlock();

            if (state === GameState.TITLE) {
                if (e.key === 'Enter' || e.key === ' ') {
                    if (hasSaveGame && loadGameState()) {
                        state = GameState.PLAYING;
                        actionPanel.classList.remove('hidden');
                        updateTurnInfo();
                        AudioSystem.sfx.select();
                    } else {
                        state = GameState.RACE_SELECT;
                        AudioSystem.sfx.select();
                    }
                }
                return;
            }

            if (state === GameState.RACE_SELECT) {
                if (e.key === 'ArrowUp') {
                    raceSelectIndex = (raceSelectIndex - 1 + RACES.length) % RACES.length;
                    AudioSystem.sfx.select();
                } else if (e.key === 'ArrowDown') {
                    raceSelectIndex = (raceSelectIndex + 1) % RACES.length;
                    AudioSystem.sfx.select();
                } else if (e.key === 'Enter' || e.key === ' ') {
                    player.race = RACES[raceSelectIndex];
                    player.color = RACES[raceSelectIndex].color;
                    initGame();
                    state = GameState.PLAYING;
                    AudioSystem.sfx.levelComplete();
                    saveGameState();
                }
                return;
            }

            if (state === GameState.PLAYING) {
                if (e.key === 'Enter') {
                    processTurn();
                    AudioSystem.sfx.select();
                } else if (e.key === 'Escape') {
                    selectedStar = null;
                    selectedShips = [];
                    movingFleet = false;
                    updateSidePanel();
                }
            }
        });

        // ============================================
        // RENDER FUNCTIONS
        // ============================================
        function renderBackground() {
            ctx.fillStyle = CONFIG.COLORS.background;
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Draw subtle grid
            ctx.strokeStyle = CONFIG.COLORS.grid;
            ctx.lineWidth = 0.5;
            for (let x = 0; x < CONFIG.WIDTH; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CONFIG.HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y < CONFIG.HEIGHT; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CONFIG.WIDTH, y);
                ctx.stroke();
            }

            // Draw distant stars
            ctx.fillStyle = '#333';
            for (let i = 0; i < 100; i++) {
                const x = (i * 97 + 23) % CONFIG.WIDTH;
                const y = (i * 53 + 17) % CONFIG.HEIGHT;
                ctx.fillRect(x, y, 1, 1);
            }
        }

        function getStarColor(star) {
            switch (star.starType) {
                case 'yellow': return CONFIG.COLORS.starYellow;
                case 'red': return CONFIG.COLORS.starRed;
                case 'blue': return CONFIG.COLORS.starBlue;
                case 'white': return CONFIG.COLORS.starWhite;
            }
            return CONFIG.COLORS.starYellow;
        }

        function renderStars() {
            // Draw travel lines for ships in transit
            ctx.strokeStyle = player.color;
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;
            for (const ship of ships) {
                if (ship.destination !== null && ship.owner === 'player') {
                    const origin = stars.find(s => s.id === ship.location);
                    const dest = stars.find(s => s.id === ship.destination);
                    if (origin && dest) {
                        ctx.beginPath();
                        ctx.moveTo(origin.x, origin.y);
                        ctx.lineTo(dest.x, dest.y);
                        ctx.stroke();
                    }
                }
            }
            ctx.setLineDash([]);

            // Draw move preview line
            if (movingFleet && selectedStar && hoveredStar && hoveredStar !== selectedStar) {
                ctx.strokeStyle = '#ffe66d';
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(selectedStar.x, selectedStar.y);
                ctx.lineTo(hoveredStar.x, hoveredStar.y);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw travel time near cursor
                const travelInfo = calculateTravelInfo(selectedStar, hoveredStar, selectedShips);
                const midX = (selectedStar.x + hoveredStar.x) / 2;
                const midY = (selectedStar.y + hoveredStar.y) / 2;

                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(midX - 35, midY - 10, 70, 20);
                ctx.fillStyle = '#ffe66d';
                ctx.font = '10px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(`${travelInfo.turns} turns`, midX, midY + 4);
            }

            for (const star of stars) {
                const isSelected = selectedStar && selectedStar.id === star.id;
                const isHovered = hoveredStar && hoveredStar.id === star.id;
                const shipsHere = getShipsAtStar(star.id).filter(s => s.owner === 'player');

                // Selection ring
                if (isSelected) {
                    ctx.strokeStyle = player.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, 22, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Hover ring
                if (isHovered && !isSelected) {
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, 20, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Owner indicator ring
                if (star.owner === 'player') {
                    ctx.strokeStyle = player.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, 16, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Star glow (only for explored stars)
                if (star.explored) {
                    const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, 15);
                    gradient.addColorStop(0, getStarColor(star));
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Star core
                ctx.fillStyle = star.explored ? getStarColor(star) : CONFIG.COLORS.unexplored;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.explored ? 6 : 4, 0, Math.PI * 2);
                ctx.fill();

                // Star name
                ctx.fillStyle = star.explored ? '#fff' : '#666';
                ctx.font = '10px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(star.name, star.x, star.y + 28);

                // Ship count indicator
                if (shipsHere.length > 0) {
                    ctx.fillStyle = player.color;
                    ctx.font = 'bold 10px Courier New';
                    ctx.fillText(`[${shipsHere.length}]`, star.x, star.y - 20);
                }

                // Planet type indicator (only if explored AND selected)
                if (star.explored && isSelected) {
                    const planetInfo = PLANET_TYPES[star.planetType];
                    ctx.fillStyle = planetInfo.color;
                    ctx.font = '9px Courier New';
                    ctx.fillText(planetInfo.name, star.x, star.y + 38);
                }
            }
        }

        function renderTitle() {
            renderBackground();

            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Title
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('GALACTIC 4X', CONFIG.WIDTH / 2, 150);

            // Subtitle
            ctx.fillStyle = '#888';
            ctx.font = '16px Courier New';
            ctx.fillText('Explore, Expand, Exploit, Exterminate', CONFIG.WIDTH / 2, 190);

            // Menu options
            if (hasSaveGame) {
                ctx.fillStyle = '#ffe66d';
                ctx.font = '16px Courier New';
                ctx.fillText('[ Continue ]', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 50);

                ctx.fillStyle = '#4ecdc4';
                ctx.fillText('[ New Game ]', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 90);
            } else {
                ctx.fillStyle = '#ffe66d';
                ctx.font = '14px Courier New';
                ctx.fillText('Click to begin', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 50);
            }

            // Description
            ctx.fillStyle = '#666';
            ctx.font = '12px Courier New';
            ctx.fillText('Build your galactic empire across the stars', CONFIG.WIDTH / 2, CONFIG.HEIGHT - 100);
            ctx.fillText('Colonize planets, build ships, and dominate the galaxy', CONFIG.WIDTH / 2, CONFIG.HEIGHT - 80);
        }

        function renderRaceSelect() {
            renderBackground();

            ctx.fillStyle = 'rgba(0,0,0,0.85)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Title
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 28px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('SELECT YOUR RACE', CONFIG.WIDTH / 2, 80);

            // Race options
            const raceY = 120;
            const raceHeight = 50;

            for (let i = 0; i < RACES.length; i++) {
                const race = RACES[i];
                const y = raceY + i * raceHeight;
                const isHovered = i === raceSelectIndex;

                // Background
                if (isHovered) {
                    ctx.fillStyle = 'rgba(78, 205, 196, 0.2)';
                    ctx.fillRect(100, y, CONFIG.WIDTH - 200, raceHeight - 5);
                }

                // Race name
                ctx.fillStyle = race.color;
                ctx.font = isHovered ? 'bold 16px Courier New' : '14px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText(race.name, 120, y + 20);

                // Description
                ctx.fillStyle = '#888';
                ctx.font = '11px Courier New';
                ctx.fillText(race.desc, 120, y + 36);

                // Selection indicator
                if (isHovered) {
                    ctx.fillStyle = race.color;
                    ctx.fillText('>', 105, y + 20);
                }
            }

            // Instructions
            ctx.fillStyle = '#666';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('Use arrows to select, Enter to confirm, or click a race', CONFIG.WIDTH / 2, CONFIG.HEIGHT - 40);
        }

        function renderPlaying() {
            renderBackground();
            renderStars();

            // Turn counter (top right)
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(CONFIG.WIDTH - 120, 10, 110, 35);
            ctx.strokeStyle = '#4a4a6a';
            ctx.strokeRect(CONFIG.WIDTH - 120, 10, 110, 35);

            ctx.fillStyle = '#ffe66d';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('Turn ' + turn, CONFIG.WIDTH - 65, 32);
        }

        // ============================================
        // AUDIO CONTROLS
        // ============================================
        document.getElementById('musicToggle').addEventListener('change', (e) => {
            AudioSystem.musicEnabled = e.target.checked;
            gameData.musicEnabled = e.target.checked;
            saveGameData();
        });

        document.getElementById('sfxToggle').addEventListener('change', (e) => {
            AudioSystem.sfxEnabled = e.target.checked;
            gameData.sfxEnabled = e.target.checked;
            saveGameData();
        });

        // Load audio preferences
        AudioSystem.musicEnabled = gameData.musicEnabled;
        AudioSystem.sfxEnabled = gameData.sfxEnabled;
        document.getElementById('musicToggle').checked = gameData.musicEnabled;
        document.getElementById('sfxToggle').checked = gameData.sfxEnabled;

        // ============================================
        // GAME LOOP
        // ============================================
        let lastFrameTime = 0;

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            GameController.poll();

            switch (state) {
                case GameState.TITLE:
                    renderTitle();
                    break;
                case GameState.RACE_SELECT:
                    renderRaceSelect();
                    break;
                case GameState.PLAYING:
                case GameState.END_TURN:
                    renderPlaying();
                    break;
            }

            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // START
        // ============================================
        // Check for existing save game
        hasSaveGame = localStorage.getItem(SAVE_KEY) !== null;

        console.log('Galactic 4X initialized');
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
