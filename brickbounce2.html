<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brick Bounce 2</title>
    <link rel="icon" type="image/x-icon" href="https://oddturnip.com/favicon_turnip.ico">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #eee;
        }
        h1 { margin-bottom: 10px; color: #ff6b6b; }
        #gameContainer { position: relative; }
        #gameCanvas { border: 4px solid #4a4a6a; border-radius: 4px; display: block; }
        #scoreDisplay {
            margin-top: 15px; padding: 10px 20px; background: #2a2a4a;
            border-radius: 4px; font-size: 18px; display: flex; gap: 30px; justify-content: center;
        }
        .score-item { text-align: center; }
        .score-label { font-size: 12px; color: #888; }
        .score-value { font-size: 24px; color: #4ecdc4; }
        .high-score .score-value { color: #ffe66d; }
        .lives .score-value { color: #ff6b6b; }
        #controls { margin-top: 10px; font-size: 12px; color: #888; }
        #audioControls {
            margin-top: 10px; font-size: 12px; color: #888;
            display: flex; gap: 20px; justify-content: center;
        }
        #audioControls label { cursor: pointer; display: flex; align-items: center; gap: 5px; }
        #audioControls input[type="checkbox"] { cursor: pointer; accent-color: #4ecdc4; }
        #powerUpLegend {
            margin-top: 15px; padding: 10px 15px; background: #2a2a4a;
            border-radius: 4px; font-size: 11px; color: #aaa;
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px 15px;
            max-width: 640px;
        }
        .pu-item { display: flex; align-items: center; gap: 6px; }
        .pu-icon { width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 10px; }
        .pu-text { line-height: 1.2; }
        .pu-name { color: #fff; font-weight: bold; }
        .pu-key { color: #ffe66d; font-size: 10px; }
    </style>
</head>
<body>
    <h1>Brick Bounce 2</h1>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="640" height="480"></canvas>
    </div>
    <div id="scoreDisplay">
        <div class="score-item lives">
            <div class="score-label">Lives</div>
            <div class="score-value" id="livesDisplay">3</div>
        </div>
        <div class="score-item">
            <div class="score-label">Score</div>
            <div class="score-value" id="currentScore">0</div>
        </div>
        <div class="score-item high-score">
            <div class="score-label">High Score</div>
            <div class="score-value" id="highScore">0</div>
        </div>
        <div class="score-item">
            <div class="score-label">Level</div>
            <div class="score-value" id="levelDisplay">1</div>
        </div>
    </div>
    <div id="controls">Move: D-Pad/Arrows | Pause: Start/Esc | Action (Laser/Release): Space/A</div>
    <div id="audioControls">
        <label><input type="checkbox" id="musicToggle" checked> Music</label>
        <label><input type="checkbox" id="sfxToggle" checked> Sound Effects</label>
    </div>
    <div id="powerUpLegend">
        <div class="pu-item"><div class="pu-icon" style="background:#ff6b6b">‚óè‚óè‚óè</div><div class="pu-text"><span class="pu-name">Multi-Ball</span><br>Splits into 3 balls</div></div>
        <div class="pu-item"><div class="pu-icon" style="background:#4ecdc4">‚îÅ‚îÅ</div><div class="pu-text"><span class="pu-name">Wide</span><br>Wider paddle</div></div>
        <div class="pu-item"><div class="pu-icon" style="background:#e74c3c">‚îÄ</div><div class="pu-text"><span class="pu-name">Narrow</span><br>Smaller paddle</div></div>
        <div class="pu-item"><div class="pu-icon" style="background:#f39c12">‚óè</div><div class="pu-text"><span class="pu-name">Sticky</span><br>Ball sticks<br><span class="pu-key">[Space to release]</span></div></div>
        <div class="pu-item"><div class="pu-icon" style="background:#9b59b6">‚ö°</div><div class="pu-text"><span class="pu-name">Laser</span><br>Shoot lasers<br><span class="pu-key">[Space to fire]</span></div></div>
        <div class="pu-item"><div class="pu-icon" style="background:#3498db">üõ°</div><div class="pu-text"><span class="pu-name">Shield</span><br>Bottom barrier (1 use)</div></div>
        <div class="pu-item"><div class="pu-icon" style="background:#2ecc71">‚ô•</div><div class="pu-text"><span class="pu-name">Extra Life</span><br>+1 life</div></div>
        <div class="pu-item"><div class="pu-icon" style="background:#1abc9c">‚è∞</div><div class="pu-text"><span class="pu-name">Slow-Mo</span><br>Slows ball (10s)</div></div>
    </div>

    <script src="controller.js"></script>
    <script src="audio.js"></script>
    <script src="storage.js"></script>
    <script src="brickbounce2-levels.js"></script>
    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            WIDTH: 640,
            HEIGHT: 480,
            BORDER_SIZE: 8,
            PADDLE_WIDTH: 80,
            PADDLE_HEIGHT: 12,
            PADDLE_SPEED: 7,
            PADDLE_Y: 450,
            BALL_SIZE: 10,
            BALL_SPEED_INITIAL: 5,
            BALL_SPEED_PER_LEVEL: 0.3,
            BALL_MAX_SPEED: 12,
            BRICK_WIDTH: 58,
            BRICK_HEIGHT: 20,
            BRICK_PADDING: 4,
            BRICK_TOP_OFFSET: 50,
            BRICK_LEFT_OFFSET: 12,
            INITIAL_LIVES: 3,
            POWERUP_DROP_CHANCE: 0.15,
            POWERUP_SPEED: 2,
            POWERUP_SIZE: 20,
            LASER_SPEED: 8,
            LASER_WIDTH: 4,
            LASER_HEIGHT: 15,
            COLORS: {
                background: '#000000',
                paddle: '#4ecdc4',
                ball: '#ffffff',
                text: '#ffffff',
                textHighlight: '#ffe66d'
            }
        };

        // ============================================
        // BRICK TYPES
        // ============================================
        const BrickType = {
            NORMAL: 'normal',
            DOUBLE: 'double',      // 2 hits
            TRIPLE: 'triple',      // 3 hits
            METAL: 'metal',        // Indestructible
            EXPLOSIVE: 'explosive', // Destroys neighbors
            MOVING: 'moving'       // Moves left/right
        };

        const BRICK_COLORS = {
            normal: '#4a9eff',  // Single color for all normal bricks
            double: '#ff8c42',
            triple: '#c73e1d',
            metal: '#7f8c8d',
            explosive: '#e74c3c',
            moving: '#1abc9c'
        };

        // ============================================
        // POWER-UP TYPES
        // ============================================
        const PowerUpType = {
            MULTI_BALL: { name: 'Multi-Ball', color: '#ff6b6b', symbol: 'M' },
            WIDE_PADDLE: { name: 'Wide', color: '#4ecdc4', symbol: 'W' },
            NARROW_PADDLE: { name: 'Narrow', color: '#e74c3c', symbol: 'N' },
            STICKY: { name: 'Sticky', color: '#f39c12', symbol: 'S' },
            LASER: { name: 'Laser', color: '#9b59b6', symbol: 'L' },
            SHIELD: { name: 'Shield', color: '#3498db', symbol: 'H' },
            EXTRA_LIFE: { name: 'Extra Life', color: '#2ecc71', symbol: '+' },
            SLOW_MO: { name: 'Slow-Mo', color: '#1abc9c', symbol: 'T' }
        };
        const POWERUP_TYPES = Object.keys(PowerUpType);

        // LEVELS loaded from brickbounce2-levels.js

        // ============================================
        // PERSISTENCE
        // ============================================
        const GAME_ID = 'brickbounce2';
        let gameData = GameStorage.load(GAME_ID, {
            ...GameStorage.defaults.levelBased(),
            totalBricksDestroyed: 0,
            totalDeaths: 0,
            powerUpsCollected: 0
        });

        function saveGameData() {
            GameStorage.save(GAME_ID, gameData);
        }

        // ============================================
        // GAME STATE
        // ============================================
        const GameState = {
            MAIN_MENU: 'main_menu',
            LEVEL_SELECT: 'level_select',
            PLAYING: 'playing',
            PAUSED: 'paused',
            LEVEL_COMPLETE: 'level_complete',
            GAME_OVER: 'game_over',
            VICTORY: 'victory'
        };

        let state = GameState.MAIN_MENU;
        let score = 0;
        let lives = CONFIG.INITIAL_LIVES;
        let level = 1;
        let pauseTime = 0;
        const UNPAUSE_DELAY = 250;

        let isNewHighScore = false;

        // ============================================
        // GAME OBJECTS
        // ============================================
        const paddle = {
            x: CONFIG.WIDTH / 2 - CONFIG.PADDLE_WIDTH / 2,
            y: CONFIG.PADDLE_Y,
            width: CONFIG.PADDLE_WIDTH,
            baseWidth: CONFIG.PADDLE_WIDTH,
            height: CONFIG.PADDLE_HEIGHT,
            sticky: false,
            hasLaser: false,
            color: CONFIG.COLORS.paddle
        };

        let balls = [];
        let bricks = [];
        let powerUps = [];
        let lasers = [];
        let particles = [];
        let shieldActive = false;
        let slowMoActive = false;
        let slowMoTimer = 0;

        // Screen shake
        let screenShake = { x: 0, y: 0, intensity: 0 };

        // Ball trail
        let ballTrails = [];

        // Power-up text popups
        let powerUpTexts = [];

        // Menu selection
        let menuSelection = 0;
        let levelSelectIndex = 0;

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 4,
                    color
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2; // gravity
                p.life -= p.decay;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function renderParticles() {
            for (const p of particles) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
            }
            ctx.globalAlpha = 1;
        }

        // ============================================
        // BALL TRAIL
        // ============================================
        function updateBallTrails() {
            // Add current positions
            for (const ball of balls) {
                ballTrails.push({ x: ball.x, y: ball.y, life: 1 });
            }
            // Update and remove old trails
            for (let i = ballTrails.length - 1; i >= 0; i--) {
                ballTrails[i].life -= 0.1;
                if (ballTrails[i].life <= 0) ballTrails.splice(i, 1);
            }
            // Limit trail length
            while (ballTrails.length > 50) ballTrails.shift();
        }

        function renderBallTrails() {
            for (const t of ballTrails) {
                ctx.globalAlpha = t.life * 0.3;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(t.x, t.y, CONFIG.BALL_SIZE / 2 * t.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        // ============================================
        // SCREEN SHAKE
        // ============================================
        function triggerScreenShake(intensity = 5) {
            screenShake.intensity = intensity;
        }

        function updateScreenShake() {
            if (screenShake.intensity > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.intensity *= 0.9;
                if (screenShake.intensity < 0.5) screenShake.intensity = 0;
            } else {
                screenShake.x = 0;
                screenShake.y = 0;
            }
        }

        // ============================================
        // POWER-UP TEXT POPUP
        // ============================================
        function createPowerUpText(name) {
            powerUpTexts.push({
                text: name,
                x: paddle.x + paddle.width / 2,
                y: paddle.y - 20,
                life: 1.0,
                vy: -1
            });
        }

        function updatePowerUpTexts() {
            for (let i = powerUpTexts.length - 1; i >= 0; i--) {
                const t = powerUpTexts[i];
                t.y += t.vy;
                t.life -= 0.02;
                if (t.life <= 0) {
                    powerUpTexts.splice(i, 1);
                }
            }
        }

        function renderPowerUpTexts() {
            for (const t of powerUpTexts) {
                ctx.globalAlpha = t.life;
                ctx.fillStyle = '#888888';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(t.text, t.x, t.y);
            }
            ctx.globalAlpha = 1;
        }

        // ============================================
        // BRICK CREATION
        // ============================================
        function createBricksFromLevel(levelIndex) {
            bricks = [];
            const levelData = LEVELS[Math.min(levelIndex - 1, LEVELS.length - 1)];
            const pattern = levelData.pattern;

            for (let row = 0; row < pattern.length; row++) {
                const rowStr = pattern[row];
                for (let col = 0; col < rowStr.length; col++) {
                    const char = rowStr[col];
                    if (char === '.') continue;

                    let type = BrickType.NORMAL;
                    let hits = 1;
                    let color;
                    let moveDir = 0;

                    switch (char) {
                        case 'N': type = BrickType.NORMAL; color = BRICK_COLORS.normal; break;
                        case 'D': type = BrickType.DOUBLE; hits = 2; color = BRICK_COLORS.double; break;
                        case 'T': type = BrickType.TRIPLE; hits = 3; color = BRICK_COLORS.triple; break;
                        case 'M': type = BrickType.METAL; hits = -1; color = BRICK_COLORS.metal; break;
                        case 'E': type = BrickType.EXPLOSIVE; color = BRICK_COLORS.explosive; break;
                        case 'V': type = BrickType.MOVING; color = BRICK_COLORS.moving; moveDir = Math.random() > 0.5 ? 1 : -1; break;
                        default: continue;
                    }

                    // Pre-determine if this brick will drop a power-up
                    const hasPowerUp = type !== BrickType.METAL && Math.random() < CONFIG.POWERUP_DROP_CHANCE;

                    bricks.push({
                        x: CONFIG.BRICK_LEFT_OFFSET + col * (CONFIG.BRICK_WIDTH + CONFIG.BRICK_PADDING),
                        y: CONFIG.BRICK_TOP_OFFSET + row * (CONFIG.BRICK_HEIGHT + CONFIG.BRICK_PADDING),
                        width: CONFIG.BRICK_WIDTH,
                        height: CONFIG.BRICK_HEIGHT,
                        type,
                        hits,
                        maxHits: hits,
                        color,
                        baseColor: color,
                        alive: true,
                        row,
                        moveDir,
                        moveSpeed: 1,
                        hasPowerUp
                    });
                }
            }
        }

        function countDestructibleBricks() {
            return bricks.filter(b => b.alive && b.type !== BrickType.METAL).length;
        }

        // ============================================
        // POWER-UP FUNCTIONS
        // ============================================
        function spawnPowerUp(x, y, guaranteed = false) {
            if (!guaranteed) return;  // Only spawn if brick had pre-determined power-up
            const typeKey = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
            const type = PowerUpType[typeKey];
            powerUps.push({
                x, y,
                vy: CONFIG.POWERUP_SPEED,
                type,
                size: CONFIG.POWERUP_SIZE
            });
        }

        function applyPowerUp(type) {
            AudioSystem.sfx.powerUp();
            gameData.powerUpsCollected++;
            score += 3;
            createPowerUpText(type.name);
            updateDisplays();

            switch (type) {
                case PowerUpType.MULTI_BALL:
                    const newBalls = [];
                    for (const ball of balls) {
                        // Create 2 new balls at different angles
                        const angles = [-Math.PI/4, Math.PI/4]; // -45¬∞ and +45¬∞ from vertical
                        for (const angleOffset of angles) {
                            const baseAngle = Math.atan2(-Math.abs(ball.vy), ball.vx);
                            const newAngle = baseAngle + angleOffset;
                            newBalls.push({
                                x: ball.x,
                                y: ball.y,
                                vx: Math.cos(newAngle) * ball.speed,
                                vy: Math.sin(newAngle) * ball.speed,
                                size: ball.size,
                                speed: ball.speed,
                                stuck: false,
                                stuckOffset: 0
                            });
                        }
                    }
                    balls.push(...newBalls);
                    break;

                case PowerUpType.WIDE_PADDLE:
                    paddle.width = Math.min(paddle.baseWidth * 1.5, 160);
                    paddle.x = Math.max(CONFIG.BORDER_SIZE, Math.min(CONFIG.WIDTH - CONFIG.BORDER_SIZE - paddle.width, paddle.x));
                    break;

                case PowerUpType.NARROW_PADDLE:
                    paddle.width = Math.max(paddle.baseWidth * 0.6, 30);
                    break;

                case PowerUpType.STICKY:
                    paddle.sticky = true;
                    paddle.color = '#f39c12';
                    break;

                case PowerUpType.LASER:
                    paddle.hasLaser = true;
                    paddle.color = '#9b59b6';
                    break;

                case PowerUpType.SHIELD:
                    shieldActive = true;
                    break;

                case PowerUpType.EXTRA_LIFE:
                    lives++;
                    updateDisplays();
                    break;

                case PowerUpType.SLOW_MO:
                    slowMoActive = true;
                    slowMoTimer = 300; // frames
                    break;
            }
        }

        // ============================================
        // GAME FUNCTIONS
        // ============================================
        function createBall() {
            const speed = Math.min(CONFIG.BALL_SPEED_INITIAL + (level - 1) * CONFIG.BALL_SPEED_PER_LEVEL, CONFIG.BALL_MAX_SPEED);
            const angle = (Math.random() * 60 + 60) * Math.PI / 180;
            return {
                x: CONFIG.WIDTH / 2,
                y: CONFIG.HEIGHT - 100,
                vx: Math.cos(angle) * speed * (Math.random() > 0.5 ? 1 : -1),
                vy: -Math.abs(Math.sin(angle) * speed),
                size: CONFIG.BALL_SIZE,
                speed,
                stuck: false,
                stuckOffset: 0
            };
        }

        function resetLevel() {
            balls = [createBall()];
            powerUps = [];
            lasers = [];
            particles = [];
            ballTrails = [];
            paddle.width = paddle.baseWidth;
            paddle.x = CONFIG.WIDTH / 2 - paddle.width / 2;
            paddle.sticky = false;
            paddle.hasLaser = false;
            paddle.color = CONFIG.COLORS.paddle;
            shieldActive = false;
            slowMoActive = false;
            createBricksFromLevel(level);
        }

        function resetGame() {
            score = 0;
            lives = CONFIG.INITIAL_LIVES;
            level = 1;
            isNewHighScore = false;
            resetLevel();
            updateDisplays();
        }

        function startGame(startLevel = 1) {
            level = startLevel;
            resetGame();
            level = startLevel; // Reset again after resetGame
            resetLevel();
            state = GameState.PLAYING;
            AudioSystem.music.start('breakout');
            gameData.gamesPlayed++;
            saveGameData();
        }

        function nextLevel() {
            score += level * 10;
            level++;
            if (level > LEVELS.length) {
                state = GameState.VICTORY;
                AudioSystem.music.stop();
                checkHighScore();
            } else {
                resetLevel();
                state = GameState.PLAYING;
                AudioSystem.music.stop();
                AudioSystem.music.start('breakout');
            }
            updateDisplays();
        }

        function loseLife() {
            lives--;
            gameData.totalDeaths++;
            AudioSystem.sfx.death();
            triggerScreenShake(10);

            if (lives <= 0) {
                endGame();
            } else {
                // Reset ball but keep paddle position and falling power-ups
                balls = [createBall()];
                lasers = [];
                shieldActive = false;
            }
            updateDisplays();
        }

        function checkHighScore() {
            if (score > gameData.highScore) {
                gameData.highScore = score;
                isNewHighScore = true;
            }
            if (level > gameData.highestLevel) {
                gameData.highestLevel = level;
            }
            saveGameData();
        }

        function endGame() {
            checkHighScore();
            state = GameState.GAME_OVER;
            AudioSystem.music.stop();
            AudioSystem.sfx.gameOver();
        }

        function updateDisplays() {
            document.getElementById('currentScore').textContent = score;
            document.getElementById('highScore').textContent = gameData.highScore;
            document.getElementById('livesDisplay').textContent = lives;
            document.getElementById('levelDisplay').textContent = level;
        }

        // ============================================
        // UPDATE FUNCTIONS
        // ============================================
        function updateMainMenu() {
            if (GameController.justPressed('up')) {
                menuSelection = Math.max(0, menuSelection - 1);
                AudioSystem.sfx.select();
            }
            if (GameController.justPressed('down')) {
                menuSelection = Math.min(1, menuSelection + 1);
                AudioSystem.sfx.select();
            }
            if (GameController.anyButtonJustPressed() && !GameController.direction.up && !GameController.direction.down) {
                AudioSystem.sfx.select();
                switch (menuSelection) {
                    case 0: startGame(); break;
                    case 1: state = GameState.LEVEL_SELECT; levelSelectIndex = 0; break;
                }
            }
        }

        function updateLevelSelect() {
            const maxLevel = Math.min(gameData.highestLevel, LEVELS.length);
            if (GameController.justPressed('left')) {
                levelSelectIndex = Math.max(0, levelSelectIndex - 1);
                AudioSystem.sfx.select();
            }
            if (GameController.justPressed('right')) {
                levelSelectIndex = Math.min(maxLevel - 1, levelSelectIndex + 1);
                AudioSystem.sfx.select();
            }
            if (GameController.justPressed('b') || GameController.justPressed('back')) {
                state = GameState.MAIN_MENU;
                AudioSystem.sfx.select();
            }
            if (GameController.justPressed('a') || GameController.justPressed('start')) {
                startGame(levelSelectIndex + 1);
            }
        }

        function updatePlaying() {
            // Pause
            if (GameController.justPressed('start')) {
                pauseTime = Date.now();
                state = GameState.PAUSED;
                AudioSystem.music.stop();
                return;
            }

            // Slow-mo timer
            if (slowMoActive) {
                slowMoTimer--;
                if (slowMoTimer <= 0) slowMoActive = false;
            }

            const speedMult = slowMoActive ? 0.5 : 1;

            // Move paddle
            if (GameController.direction.left) paddle.x -= CONFIG.PADDLE_SPEED;
            if (GameController.direction.right) paddle.x += CONFIG.PADDLE_SPEED;
            paddle.x = Math.max(CONFIG.BORDER_SIZE, Math.min(CONFIG.WIDTH - CONFIG.BORDER_SIZE - paddle.width, paddle.x));

            // Shoot laser (Y button or spacebar)
            const fireLaser = GameController.justPressed('y') || spaceJustPressed;
            spaceJustPressed = false; // Reset flag each frame
            if (paddle.hasLaser && fireLaser) {
                lasers.push({ x: paddle.x + 10, y: paddle.y, vy: -CONFIG.LASER_SPEED });
                lasers.push({ x: paddle.x + paddle.width - 10, y: paddle.y, vy: -CONFIG.LASER_SPEED });
                AudioSystem.sfx.shoot();
            }

            // Update lasers
            for (let i = lasers.length - 1; i >= 0; i--) {
                lasers[i].y += lasers[i].vy;
                if (lasers[i].y < 0) lasers.splice(i, 1);
            }

            // Update moving bricks
            for (const brick of bricks) {
                if (brick.type === BrickType.MOVING && brick.alive) {
                    brick.x += brick.moveDir * brick.moveSpeed;
                    if (brick.x <= CONFIG.BORDER_SIZE || brick.x + brick.width >= CONFIG.WIDTH - CONFIG.BORDER_SIZE) {
                        brick.moveDir *= -1;
                    }
                }
            }

            // Release stuck balls when A is pressed
            if (GameController.justPressed('a')) {
                for (const ball of balls) {
                    if (ball.stuck) {
                        ball.stuck = false;
                        const hitPos = (ball.x - paddle.x) / paddle.width;
                        const angle = (hitPos - 0.5) * Math.PI * 0.7;
                        ball.vx = Math.sin(angle) * ball.speed;
                        ball.vy = -Math.cos(angle) * ball.speed;
                        // Sticky is consumed after one use
                        paddle.sticky = false;
                        paddle.color = paddle.hasLaser ? '#9b59b6' : CONFIG.COLORS.paddle;
                    }
                }
            }

            // Update balls
            for (let bi = balls.length - 1; bi >= 0; bi--) {
                const ball = balls[bi];

                // Update stuck ball position
                if (ball.stuck) {
                    ball.x = paddle.x + paddle.width / 2 + ball.stuckOffset;
                    ball.y = paddle.y - ball.size / 2;
                    continue; // Skip movement for stuck balls
                }

                // Move
                ball.x += ball.vx * speedMult;
                ball.y += ball.vy * speedMult;

                // Wall collisions
                if (ball.x - ball.size/2 <= CONFIG.BORDER_SIZE) {
                    ball.x = CONFIG.BORDER_SIZE + ball.size/2;
                    ball.vx = Math.abs(ball.vx);
                    AudioSystem.sfx.wallHit();
                }
                if (ball.x + ball.size/2 >= CONFIG.WIDTH - CONFIG.BORDER_SIZE) {
                    ball.x = CONFIG.WIDTH - CONFIG.BORDER_SIZE - ball.size/2;
                    ball.vx = -Math.abs(ball.vx);
                    AudioSystem.sfx.wallHit();
                }
                if (ball.y - ball.size/2 <= CONFIG.BORDER_SIZE) {
                    ball.y = CONFIG.BORDER_SIZE + ball.size/2;
                    ball.vy = Math.abs(ball.vy);
                    AudioSystem.sfx.wallHit();
                }

                // Paddle collision
                if (ball.vy > 0 &&
                    ball.y + ball.size/2 >= paddle.y &&
                    ball.y - ball.size/2 <= paddle.y + paddle.height &&
                    ball.x >= paddle.x && ball.x <= paddle.x + paddle.width) {

                    ball.y = paddle.y - ball.size/2;

                    if (paddle.sticky) {
                        // Stick the ball to the paddle
                        ball.stuck = true;
                        ball.stuckOffset = ball.x - (paddle.x + paddle.width / 2);
                        ball.vx = 0;
                        ball.vy = 0;
                    } else {
                        const hitPos = (ball.x - paddle.x) / paddle.width;
                        const angle = (hitPos - 0.5) * Math.PI * 0.7;
                        ball.vx = Math.sin(angle) * ball.speed;
                        ball.vy = -Math.cos(angle) * ball.speed;
                    }
                    AudioSystem.sfx.paddleHit();
                }

                // Ball falls - check shield
                if (ball.y - ball.size/2 > CONFIG.HEIGHT) {
                    if (shieldActive) {
                        ball.y = CONFIG.HEIGHT - 20;
                        ball.vy = -Math.abs(ball.vy);
                        shieldActive = false;
                    } else {
                        balls.splice(bi, 1);
                    }
                }
            }

            // If all balls lost
            if (balls.length === 0) {
                loseLife();
                return;
            }

            // Brick collisions (balls)
            for (const ball of balls) {
                for (const brick of bricks) {
                    if (!brick.alive) continue;
                    if (ball.x + ball.size/2 >= brick.x &&
                        ball.x - ball.size/2 <= brick.x + brick.width &&
                        ball.y + ball.size/2 >= brick.y &&
                        ball.y - ball.size/2 <= brick.y + brick.height) {

                        hitBrick(brick);

                        // Bounce
                        const overlapLeft = (ball.x + ball.size/2) - brick.x;
                        const overlapRight = (brick.x + brick.width) - (ball.x - ball.size/2);
                        const overlapTop = (ball.y + ball.size/2) - brick.y;
                        const overlapBottom = (brick.y + brick.height) - (ball.y - ball.size/2);
                        const minX = Math.min(overlapLeft, overlapRight);
                        const minY = Math.min(overlapTop, overlapBottom);
                        if (minX < minY) ball.vx = -ball.vx;
                        else ball.vy = -ball.vy;

                        break;
                    }
                }
            }

            // Brick collisions (lasers)
            for (let li = lasers.length - 1; li >= 0; li--) {
                const laser = lasers[li];
                for (const brick of bricks) {
                    if (!brick.alive) continue;
                    if (laser.x >= brick.x && laser.x <= brick.x + brick.width &&
                        laser.y >= brick.y && laser.y <= brick.y + brick.height) {
                        hitBrick(brick);
                        lasers.splice(li, 1);
                        break;
                    }
                }
            }

            // Power-up collection
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pu = powerUps[i];
                pu.y += pu.vy;

                // Collect
                if (pu.y + pu.size/2 >= paddle.y &&
                    pu.y - pu.size/2 <= paddle.y + paddle.height &&
                    pu.x >= paddle.x && pu.x <= paddle.x + paddle.width) {
                    applyPowerUp(pu.type);
                    powerUps.splice(i, 1);
                    continue;
                }

                // Fall off
                if (pu.y > CONFIG.HEIGHT) {
                    powerUps.splice(i, 1);
                }
            }

            // Check level complete
            if (countDestructibleBricks() === 0) {
                state = GameState.LEVEL_COMPLETE;
                AudioSystem.sfx.levelComplete();
            }

            // Update effects
            updateParticles();
            updateBallTrails();
            updateScreenShake();
            updatePowerUpTexts();
        }

        function hitBrick(brick) {
            AudioSystem.sfx.brickHit();

            if (brick.type === BrickType.METAL) {
                // Metal bricks can't be destroyed
                createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 3);
                return;
            }

            brick.hits--;
            if (brick.hits <= 0) {
                brick.alive = false;
                score += 1;
                gameData.totalBricksDestroyed++;
                createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 15);
                spawnPowerUp(brick.x + brick.width/2, brick.y + brick.height/2, brick.hasPowerUp);

                // Explosive
                if (brick.type === BrickType.EXPLOSIVE) {
                    AudioSystem.sfx.explosion();
                    triggerScreenShake(8);
                    for (const other of bricks) {
                        if (!other.alive || other === brick) continue;
                        const dx = Math.abs((other.x + other.width/2) - (brick.x + brick.width/2));
                        const dy = Math.abs((other.y + other.height/2) - (brick.y + brick.height/2));
                        if (dx < CONFIG.BRICK_WIDTH * 1.5 && dy < CONFIG.BRICK_HEIGHT * 1.5) {
                            hitBrick(other);
                        }
                    }
                }
            } else {
                // Fade color for multi-hit bricks
                const ratio = brick.hits / brick.maxHits;
                brick.color = fadeColor(brick.baseColor, ratio);
            }
            updateDisplays();
        }

        function fadeColor(hex, ratio) {
            const r = parseInt(hex.slice(1,3), 16);
            const g = parseInt(hex.slice(3,5), 16);
            const b = parseInt(hex.slice(5,7), 16);
            const fr = Math.floor(r * ratio + 50 * (1-ratio));
            const fg = Math.floor(g * ratio + 50 * (1-ratio));
            const fb = Math.floor(b * ratio + 50 * (1-ratio));
            return `#${fr.toString(16).padStart(2,'0')}${fg.toString(16).padStart(2,'0')}${fb.toString(16).padStart(2,'0')}`;
        }

        function updatePaused() {
            if (Date.now() - pauseTime >= UNPAUSE_DELAY && GameController.justPressed('start')) {
                state = GameState.PLAYING;
                AudioSystem.music.start('breakout');
            }
        }

        function updateLevelComplete() {
            if (GameController.anyButtonJustPressed()) {
                nextLevel();
            }
        }

        function updateGameOver() {
            if (GameController.anyButtonJustPressed()) {
                state = GameState.MAIN_MENU;
                menuSelection = 0;
            }
        }

        function updateVictory() {
            if (GameController.anyButtonJustPressed()) {
                state = GameState.MAIN_MENU;
                menuSelection = 0;
            }
        }

        // ============================================
        // RENDER FUNCTIONS
        // ============================================
        let lavaFrame = 0;

        function renderBackground() {
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);

            ctx.fillStyle = CONFIG.COLORS.background;
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            // Border
            const stoneColors = ['#4a4a5a', '#3a3a4a', '#5a5a6a', '#454555'];
            for (let x = 0; x < CONFIG.WIDTH; x += 16) {
                ctx.fillStyle = stoneColors[Math.floor(x/16) % 4];
                ctx.fillRect(x, 0, 15, CONFIG.BORDER_SIZE);
            }
            for (let y = CONFIG.BORDER_SIZE; y < CONFIG.HEIGHT - 12; y += 8) {
                ctx.fillStyle = stoneColors[Math.floor(y/8) % 4];
                ctx.fillRect(0, y, CONFIG.BORDER_SIZE, 7);
                ctx.fillRect(CONFIG.WIDTH - CONFIG.BORDER_SIZE, y, CONFIG.BORDER_SIZE, 7);
            }

            // Lava
            lavaFrame += 0.1;
            ctx.fillStyle = '#660000';
            ctx.fillRect(0, CONFIG.HEIGHT - 12, CONFIG.WIDTH, 12);
            for (let x = 0; x < CONFIG.WIDTH; x += 4) {
                const bob = Math.sin(lavaFrame + (x * 7) % 17) * 2;
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(x, CONFIG.HEIGHT - 12 + bob, 4, 12);
                ctx.fillStyle = '#ff4500';
                ctx.fillRect(x, CONFIG.HEIGHT - 8 + bob, 4, 8);
            }

            ctx.restore();
        }

        function renderShield() {
            if (!shieldActive) return;
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.3;
            ctx.beginPath();
            ctx.moveTo(CONFIG.BORDER_SIZE, CONFIG.HEIGHT - 15);
            ctx.lineTo(CONFIG.WIDTH - CONFIG.BORDER_SIZE, CONFIG.HEIGHT - 15);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        function renderPaddle() {
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);

            const gradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
            gradient.addColorStop(0, lightenColor(paddle.color, 30));
            gradient.addColorStop(0.5, paddle.color);
            gradient.addColorStop(1, darkenColor(paddle.color, 30));

            ctx.shadowColor = paddle.color;
            ctx.shadowBlur = 10;
            ctx.fillStyle = gradient;
            roundRect(ctx, paddle.x, paddle.y, paddle.width, paddle.height, 5);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Laser indicators
            if (paddle.hasLaser) {
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(paddle.x + 5, paddle.y + 2, 4, 8);
                ctx.fillRect(paddle.x + paddle.width - 9, paddle.y + 2, 4, 8);
            }

            ctx.restore();
        }

        function renderBalls() {
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);

            renderBallTrails();

            for (const ball of balls) {
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.size/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            ctx.restore();
        }

        function renderBricks() {
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);

            for (const brick of bricks) {
                if (!brick.alive) continue;

                ctx.fillStyle = brick.color;
                ctx.fillRect(brick.x, brick.y, brick.width, brick.height);

                // Highlight
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.fillRect(brick.x, brick.y, brick.width, brick.height/3);

                // Border
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

                // Power-up indicator - small star/sparkle
                if (brick.hasPowerUp) {
                    const cx = brick.x + brick.width - 8;
                    const cy = brick.y + 8;
                    ctx.fillStyle = '#ffe66d';
                    // Draw a small 4-point star
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI) / 4 - Math.PI / 2;
                        const radius = i % 2 === 0 ? 4 : 2;
                        const x = cx + Math.cos(angle) * radius;
                        const y = cy + Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Special indicators
                if (brick.type === BrickType.METAL) {
                    ctx.strokeStyle = '#95a5a6';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(brick.x + 2, brick.y + 2, brick.width - 4, brick.height - 4);
                }
                if (brick.type === BrickType.EXPLOSIVE) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', brick.x + brick.width/2, brick.y + brick.height/2 + 4);
                }
            }

            ctx.restore();
        }

        function renderPowerUps() {
            for (const pu of powerUps) {
                ctx.fillStyle = pu.type.color;
                ctx.beginPath();
                ctx.arc(pu.x, pu.y, pu.size/2, 0, Math.PI * 2);
                ctx.fill();

                // Draw pixel art symbols
                drawPowerUpPixelArt(pu.x, pu.y, pu.type);
            }
        }

        // Pixel art for power-up icons
        function drawPowerUpPixelArt(x, y, type) {
            const px = 2; // pixel size
            ctx.fillStyle = '#ffffff';

            switch (type) {
                case PowerUpType.MULTI_BALL:
                    // Three small circles
                    ctx.beginPath();
                    ctx.arc(x - 4, y, 3, 0, Math.PI * 2);
                    ctx.arc(x + 4, y - 2, 3, 0, Math.PI * 2);
                    ctx.arc(x + 2, y + 3, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case PowerUpType.WIDE_PADDLE:
                    // Wide rectangle with arrows
                    ctx.fillRect(x - 7, y - 1, 14, 3);
                    ctx.fillRect(x - 8, y - 2, 2, 5);
                    ctx.fillRect(x + 6, y - 2, 2, 5);
                    break;

                case PowerUpType.NARROW_PADDLE:
                    // Narrow rectangle with inward arrows
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(x - 3, y - 1, 6, 3);
                    ctx.fillRect(x - 6, y, 3, 1);
                    ctx.fillRect(x + 3, y, 3, 1);
                    break;

                case PowerUpType.STICKY:
                    // Glue drop shape
                    ctx.beginPath();
                    ctx.arc(x, y + 2, 4, 0, Math.PI);
                    ctx.fill();
                    ctx.fillRect(x - 2, y - 4, 4, 6);
                    break;

                case PowerUpType.LASER:
                    // Lightning bolt
                    ctx.beginPath();
                    ctx.moveTo(x + 2, y - 6);
                    ctx.lineTo(x - 2, y);
                    ctx.lineTo(x + 1, y);
                    ctx.lineTo(x - 2, y + 6);
                    ctx.lineTo(x + 2, y);
                    ctx.lineTo(x - 1, y);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case PowerUpType.SHIELD:
                    // Shield shape üõ°
                    ctx.beginPath();
                    ctx.moveTo(x, y - 6);
                    ctx.lineTo(x + 6, y - 3);
                    ctx.lineTo(x + 5, y + 2);
                    ctx.lineTo(x, y + 6);
                    ctx.lineTo(x - 5, y + 2);
                    ctx.lineTo(x - 6, y - 3);
                    ctx.closePath();
                    ctx.fill();
                    // Inner detail
                    ctx.fillStyle = type.color;
                    ctx.beginPath();
                    ctx.moveTo(x, y - 3);
                    ctx.lineTo(x + 3, y - 1);
                    ctx.lineTo(x + 2, y + 1);
                    ctx.lineTo(x, y + 3);
                    ctx.lineTo(x - 2, y + 1);
                    ctx.lineTo(x - 3, y - 1);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case PowerUpType.EXTRA_LIFE:
                    // Heart shape
                    ctx.beginPath();
                    ctx.moveTo(x, y + 4);
                    ctx.bezierCurveTo(x - 6, y, x - 6, y - 5, x, y - 2);
                    ctx.bezierCurveTo(x + 6, y - 5, x + 6, y, x, y + 4);
                    ctx.fill();
                    break;

                case PowerUpType.SLOW_MO:
                    // Clock shape üïì
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.stroke();
                    // Clock hands
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y - 4);
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 3, y + 1);
                    ctx.stroke();
                    // Center dot
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(x, y, 1, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
        }

        function renderLasers() {
            ctx.fillStyle = '#ff0000';
            for (const laser of lasers) {
                ctx.fillRect(laser.x - CONFIG.LASER_WIDTH/2, laser.y, CONFIG.LASER_WIDTH, CONFIG.LASER_HEIGHT);
            }
        }

        function renderPlaying() {
            renderBackground();
            renderShield();
            renderBricks();
            renderPowerUps();
            renderLasers();
            renderPaddle();
            renderBalls();
            renderParticles();
            renderPowerUpTexts();

            // Slow-mo indicator
            if (slowMoActive) {
                ctx.fillStyle = 'rgba(26, 188, 156, 0.2)';
                ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
                ctx.fillStyle = '#1abc9c';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText('SLOW-MO', 15, 25);
            }

            // Level name
            const levelData = LEVELS[Math.min(level - 1, LEVELS.length - 1)];
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'right';
            ctx.fillText(`${level}: ${levelData.name}`, CONFIG.WIDTH - 15, 25);
        }

        function renderMainMenu() {
            renderBackground();

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 42px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('BRICK BOUNCE 2', CONFIG.WIDTH/2, 120);

            const options = ['Start Game', 'Level Select'];
            for (let i = 0; i < options.length; i++) {
                const y = 200 + i * 50;
                if (i === menuSelection) {
                    ctx.fillStyle = '#ffe66d';
                    ctx.font = 'bold 24px Courier New';
                    ctx.fillText('> ' + options[i] + ' <', CONFIG.WIDTH/2, y);
                } else {
                    ctx.fillStyle = '#888888';
                    ctx.font = '20px Courier New';
                    ctx.fillText(options[i], CONFIG.WIDTH/2, y);
                }
            }

            // Stats display
            ctx.fillStyle = '#666666';
            ctx.font = '14px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`Games: ${gameData.gamesPlayed}`, 30, 380);
            ctx.fillText(`Bricks: ${gameData.totalBricksDestroyed}`, 30, 400);
            ctx.fillText(`Deaths: ${gameData.totalDeaths}`, 30, 420);
            ctx.fillText(`Power-ups: ${gameData.powerUpsCollected}`, 30, 440);

            ctx.textAlign = 'right';
            ctx.fillText(`High Score: ${gameData.highScore}`, CONFIG.WIDTH - 30, 400);
            ctx.fillText(`Highest Level: ${gameData.highestLevel}`, CONFIG.WIDTH - 30, 420);
        }

        function renderLevelSelect() {
            renderBackground();

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 32px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('SELECT LEVEL', CONFIG.WIDTH/2, 80);

            const maxLevel = Math.min(gameData.highestLevel, LEVELS.length);
            const cols = 5;
            const boxSize = 80;
            const startX = CONFIG.WIDTH/2 - (cols * boxSize)/2 + boxSize/2;

            for (let i = 0; i < LEVELS.length; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                const x = startX + col * boxSize;
                const y = 140 + row * boxSize;
                const unlocked = i < maxLevel;

                ctx.fillStyle = unlocked ? (i === levelSelectIndex ? '#ffe66d' : '#4ecdc4') : '#333333';
                ctx.fillRect(x - 30, y - 25, 60, 50);

                ctx.fillStyle = unlocked ? '#000000' : '#555555';
                ctx.font = 'bold 20px Courier New';
                ctx.fillText(i + 1, x, y + 7);

                if (unlocked) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '10px Courier New';
                    ctx.fillText(LEVELS[i].name, x, y + 35);
                }
            }

            ctx.fillStyle = '#888888';
            ctx.font = '14px Courier New';
            ctx.fillText('‚Üê ‚Üí to select, A to start, B to back', CONFIG.WIDTH/2, CONFIG.HEIGHT - 40);
        }

        function renderPaused() {
            renderPlaying();
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = '#ffe66d';
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', CONFIG.WIDTH/2, CONFIG.HEIGHT/2);

            ctx.fillStyle = '#ffffff';
            ctx.font = '18px Courier New';
            ctx.fillText('Press Start to Resume', CONFIG.WIDTH/2, CONFIG.HEIGHT/2 + 50);
        }

        function renderLevelComplete() {
            renderBackground();

            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = '#ffe66d';
            ctx.font = 'bold 42px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`LEVEL ${level} COMPLETE!`, CONFIG.WIDTH/2, CONFIG.HEIGHT/2 - 40);

            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Courier New';
            ctx.fillText(`Bonus: +${level * 10}`, CONFIG.WIDTH/2, CONFIG.HEIGHT/2 + 20);

            ctx.fillStyle = '#ffe66d';
            ctx.font = '18px Courier New';
            ctx.fillText('Press any button to continue', CONFIG.WIDTH/2, CONFIG.HEIGHT/2 + 80);
        }

        function renderGameOver() {
            renderBackground();

            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = '#ff6b6b';
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', CONFIG.WIDTH/2, CONFIG.HEIGHT/2 - 60);

            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Courier New';
            ctx.fillText(`Final Score: ${score}`, CONFIG.WIDTH/2, CONFIG.HEIGHT/2);
            ctx.fillText(`Reached Level: ${level}`, CONFIG.WIDTH/2, CONFIG.HEIGHT/2 + 35);

            if (isNewHighScore) {
                ctx.fillStyle = '#ffe66d';
                ctx.font = 'bold 28px Courier New';
                ctx.fillText('NEW HIGH SCORE!', CONFIG.WIDTH/2, CONFIG.HEIGHT/2 + 90);
            }

            ctx.fillStyle = '#888888';
            ctx.font = '18px Courier New';
            ctx.fillText('Press any button to continue', CONFIG.WIDTH/2, CONFIG.HEIGHT/2 + 140);
        }

        function renderVictory() {
            renderBackground();

            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

            ctx.fillStyle = '#ffe66d';
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('VICTORY!', CONFIG.WIDTH/2, CONFIG.HEIGHT/2 - 60);

            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Courier New';
            ctx.fillText('You completed all levels!', CONFIG.WIDTH/2, CONFIG.HEIGHT/2);
            ctx.fillText(`Final Score: ${score}`, CONFIG.WIDTH/2, CONFIG.HEIGHT/2 + 40);

            if (isNewHighScore) {
                ctx.fillStyle = '#ffe66d';
                ctx.font = 'bold 28px Courier New';
                ctx.fillText('NEW HIGH SCORE!', CONFIG.WIDTH/2, CONFIG.HEIGHT/2 + 100);
            }

            ctx.fillStyle = '#888888';
            ctx.font = '18px Courier New';
            ctx.fillText('Press any button to continue', CONFIG.WIDTH/2, CONFIG.HEIGHT/2 + 150);
        }

        // Helper functions
        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + r, r);
            ctx.lineTo(x + w, y + h - r);
            ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
            ctx.lineTo(x + r, y + h);
            ctx.arcTo(x, y + h, x, y + h - r, r);
            ctx.lineTo(x, y + r);
            ctx.arcTo(x, y, x + r, y, r);
            ctx.closePath();
        }

        function lightenColor(hex, percent) {
            const num = parseInt(hex.slice(1), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return `#${(1 << 24 | R << 16 | G << 8 | B).toString(16).slice(1)}`;
        }

        function darkenColor(hex, percent) {
            const num = parseInt(hex.slice(1), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            return `#${(1 << 24 | R << 16 | G << 8 | B).toString(16).slice(1)}`;
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function update() {
            GameController.poll();

            switch (state) {
                case GameState.MAIN_MENU: updateMainMenu(); break;
                case GameState.LEVEL_SELECT: updateLevelSelect(); break;
                case GameState.PLAYING: updatePlaying(); break;
                case GameState.PAUSED: updatePaused(); break;
                case GameState.LEVEL_COMPLETE: updateLevelComplete(); break;
                case GameState.GAME_OVER: updateGameOver(); break;
                case GameState.VICTORY: updateVictory(); break;
            }
        }

        function render() {
            switch (state) {
                case GameState.MAIN_MENU: renderMainMenu(); break;
                case GameState.LEVEL_SELECT: renderLevelSelect(); break;
                case GameState.PLAYING: renderPlaying(); break;
                case GameState.PAUSED: renderPaused(); break;
                case GameState.LEVEL_COMPLETE: renderLevelComplete(); break;
                case GameState.GAME_OVER: renderGameOver(); break;
                case GameState.VICTORY: renderVictory(); break;
            }
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Audio controls
        document.getElementById('musicToggle').addEventListener('change', (e) => {
            AudioSystem.musicEnabled = e.target.checked;
            gameData.musicEnabled = e.target.checked;
            saveGameData();
            if (!e.target.checked) AudioSystem.music.stop();
            else if (state === GameState.PLAYING) AudioSystem.music.start('breakout');
        });
        document.getElementById('sfxToggle').addEventListener('change', (e) => {
            AudioSystem.sfxEnabled = e.target.checked;
            gameData.sfxEnabled = e.target.checked;
            saveGameData();
        });

        // Load audio preferences
        if (gameData.musicEnabled !== undefined) {
            AudioSystem.musicEnabled = gameData.musicEnabled;
            document.getElementById('musicToggle').checked = gameData.musicEnabled;
        }
        if (gameData.sfxEnabled !== undefined) {
            AudioSystem.sfxEnabled = gameData.sfxEnabled;
            document.getElementById('sfxToggle').checked = gameData.sfxEnabled;
        }

        // Additional keyboard flag for spacebar-fires-laser behavior
        // (Controller.js already maps Space to 'a' for releasing balls, this adds laser fire)
        let spaceJustPressed = false;
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && state === GameState.PLAYING) {
                spaceJustPressed = true;
            }
        });

        // Start
        console.log('Brick Bounce 2 initialized');
        updateDisplays();
        gameLoop();
    </script>
</body>
</html>
